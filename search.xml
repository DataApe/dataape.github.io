<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Think Python 读书笔记]]></title>
      <url>%2F2017%2F04%2F10%2FThink_Python%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[第一章：程序之道第一个程序1234567# Python3中，print是一个函数；&gt;&gt;&gt; print('Hello, World!')Hello, World!# Python2中，print是一个语句；不是函数，所以不需要使用括号。&gt;&gt;&gt; print 'Hello, World!'Hello, World! 值和类型 值 类型 2 整型数（integer） 42.0 浮点数（floating） ‘Hello,Word!’ 字符串（string） 不确定某个值的类型是什么时，解释器可以告诉你：12&gt;&gt;&gt; type(2)&lt;type 'int'&gt; 第二章：变量、表达式和语句变量名可以包括字母和数字，但是不能以数字开头。下划线_可以出现在变量名中。12&gt;&gt;&gt; class = 'Advanced Theoretical Zymurgy'SyntaxError: invalid syntax class 是Python的关键字之一。 解释器使用关键字识别程序的结构，它们不能被用作变量名。Python3有以下关键词： False None True and as assert break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass raise return try while with yield – – 脚本模式到目前为止，我们都是在交互模式（interactive mode）下运行Python，即直接与解释器进行交互。另一种方法是将代码保存到一个被称为脚本（script）的文件里，然后以脚本模式（script mode）运行解释器并执行脚本（.py）。 字符串运算加号运算符 + 可用于字符串拼接（string concatenation），也就是将字符串首尾相连起来。1234&gt;&gt;&gt; first = 'throat'&gt;&gt;&gt; second = 'warbler'&gt;&gt;&gt; first + secondthroatwarbler 乘法运算符 * 也可应用于字符串；它执行重复运算。 例如，&#39;Spam&#39; * 3 的结果是 ‘SpamSpamSpam’ 。 第三章：函数数学函数Python中有一个数学模块（math），提供了大部分常用的数学函数。模块（module）指的是一个含有相关函数的文件。在使用模块之前，我们需要通过导入语句（import statement）导入该模块：123&gt;&gt;&gt; import math&gt;&gt;&gt; math.sqrt(2) / 2.00.707106781187 组合编程语言的最有用特征之一，是能够将小块构建材料（building blocks）组合（compose）在一起。 例如，函数的实参可以是任意类型的表达式，包括算术运算符：1x = math.sin(degrees / 360.0 * 2 * math.pi) 术语表 名词 定义 形参（parameters） 函数内部用于指向被传作实参的值的名字 实参（argument） 函数调用时传给函数的值。这个值被赋给函数中相对应的形参 局部变量（local variable） 函数内部定义的变量。局部变量只能在函数内部使用 模块（module） 包含了一组相关函数及其他定义的的文件 导入语句（import statement） 读取一个模块文件，并创建一个模块对象的语句 回溯（traceback） 当出现异常时，解释器打印出的出错时正在执行的函数列表 第四章：案例研究：接口设计在cmd下运行Python脚本方法1 新建个.py文件，写上Python代码，每个.py文件都是可以认为是一个Python模块 打开Windows的cmd，并且切换（cd）到对应的python脚本所在目录 输入你的Python脚本，即.py文件的完整的文件名 可以利用Tab键，然后会自动显示出当前目录的文件，多次按Tab键，会在多个文件之间切换。 然后输入回车，即可运行对应的Python脚本 方法2 Python D\:Python27\mypy\文件名.py 如何使用Python的交互式的shell（command line模式和GUI模式）Python有个shell，提供一个Python运行环境。即写一行代码，就可以立刻被运行，然后方便查看到结果。而Python的Shell，在Windows环境下，又分两种：Python (command line) 和IDLE (Python GUI)，两者都比较适合偶尔要测试少量的Python代码的情况下去使用，而不适合长期的开发Python。 如果要调用另一个python脚本用 import 文件名（不包括.py)，这个脚本要在PYTHONPATH的路径下。 在python里建一个文件夹，专门存放你的模块，例如：在python.exe路径下建了一个名为mypy的文件夹 设置一个环境变量PYTHONPATH，以便Python解释器找到相应模块 步骤：计算机&gt;&gt;属性&gt;&gt;高级系统设置&gt;&gt;环境变量&gt;&gt;系统变量&gt;&gt;新建&gt;&gt;变量名：PYTHONPATH; 变量值：D\:Python27\mypy 执行以下代码，mypy也会同其他系统path一起显示出来！12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path ​ 什么是Python的IDE开发Python过程中，写Python代码，调试Python代码，查找相关的函数的解释等等操作，如果都是基于前面介绍的，用Notepad++等编辑器去编辑Python代码，写完代码了，再切换到windows的cmd中去运行，往往觉得很麻烦。尤其是大型项目的话，可能就更加显得不那么高效；以及对应的需要一些额外的功能，比如调试复杂的Python代码，需要一点点跟踪调试，找到错误的根本原因等等。 Python发展到现在，已经有了很多第三方的，别人开发的，可以用于或者专门用于Python开发的一些集成开发环境，即Python的IDE。 术语表： 名词 定义 封装（encapsulation） 将一个语句序列转换成函数定义的过程 泛化（generalization） 使用某种可以算是比较通用的东西（像变量和形参），替代某些没必要那么具体的东西（像一个数字）的过程 关键字实参（keyword argument） 包括了形参名称作为“关键字”的实参 接口（interface） 对如何使用一个函数的描述，包括函数名、参数说明和返回值 重构（refactoring） 修改一个正常运行的函数，改善函数接口及其他方面代码质量的过程 第五章：条件和递归递归一个调用它自己的函数是递归的（recursive）； 这个过程被称作递归（recursion），例如：12345678&gt;&gt;&gt; def countdown(n): if n &lt;= 0: print('Blastoff!') else: print(n) countdown(n-1)&gt;&gt;&gt; countdown(3) 堆栈图 在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。 每当一个函数被调用时，Python生成一个新的栈帧，用于保存函数的局部变量和形参。通常，堆栈的顶部是__main__栈帧。 因为我们在__main__中没有创建任何变量，也没有传递任何实参给它， 所以它是空的。 对于形参n，四个 countdown 栈帧有不同的值。 n=0的栈底，被称作基础情形（base case）。 它不再进行递归调用了，所以没有更多的栈帧了。 举个栗子：阶乘 n!=n(n−1)!1234567&gt;&gt;&gt; def factorial(n): if n == 0: return 1 else: recurse = factorial(n-1) result = n * recurse return result 堆栈图该图中的返回值被描绘为不断被传回到栈顶。 在每个栈帧中，返回值就是结果值，即是 n 和 recurse 的乘积。 再举个栗子：斐波那契数列除了阶乘以外，使用递归定义的最常见数学函数是 fibonaccifibonacci(0) = 0fibonacci(1) = 1fibonacci(n) = fibonacci(n−1) + fibonacci(n−2)1234567def fibonacci (n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2) 如果我们将 1.5 作为参数调用阶乘函数会怎样？看上去像是一个无限循环。函数的基础情形是 n == 0 。 但是如果 n 不是一个整型数呢，我们会错过基础情形，永远递归下去。在第一次递归调用中，n 的值是 0.5 。下一次，是 -0.5 。自此它会越来越小，但永远不会是 0 。 我们可以使用内建函数 isinstance 来验证实参的类型。确保该实参是正数：1234567891011def factorial (n): if not isinstance(n, int): print('Factorial is only defined for integers.') return None elif n &lt; 0: print('Factorial is not defined for negative integers.') return None elif n == 0: return 1 else: return n * factorial(n-1) 此程序演示了一个有时被称作 监护人（guardian） 的模式。 前两个条件扮演监护人的角色，避免接下来的代码使用引发错误的值。 术语表 名词 定义 临时变量（temporary variable） 一个在复杂计算中用于存储过度值的变量 死代码（dead code） 程序中永远无法执行的那部分代码，通常是因为其出现在一个返回语句之后 增量式开发（incremental development） 一种程序开发计划，目的是通过一次增加及测试少量代码的方式，来避免长时间的调试 脚手架代码（scaffolding） 程序开发中使用的代码，但并不是最终版本的一部分 监护人（guardian） 一种编程模式，使用条件语句来检查并处理可能引发错误的情形 第七章：迭代迭代，即重复运行某个代码块的能力。 之前已经接触了一种利用递归进行迭代的方式； 在简单的重复一节中，接触了另一种利用 for 循环进行迭代的方式。 在本章中，我们将讨论另外一种利用 while 语句实现迭代的方式。12345def countdown(n): while n &gt; 0: print(n) n = n - 1 print('Blastoff!') while 语句 首先判断条件为真还是为假。 如果为假，退出 while 语句，然后执行接下来的语句； 如果条件为真，则运行 while 语句体，运行完再返回第一步； 这种形式的流程叫做循环（loop），因为第三步后又循环回到了第一步。 break有些时候循环执行到一半你才知道循环该结束了。这种情况下，你可以使用break语句来跳出循环。 调试更多的代码意味着更高的出错概率，并且会有更多隐藏 bug 的地方。减少调试时间的一个方法就是 对分调试 。例如，如果程序有100行，你一次检查一行，就需要100步。 术语表 名词 定义 初始化（initialize） 给后面将要更新的变量一个初始值的一种赋值方法 递增（increment） 通过增加变量的值的方式更新变量（通常是加 1） 递减（decrement） 通过减少变量的值的方式来更新变量 迭代（iteration） 利用递归或者循环的方式来重复执行代一组语句的过程 第八章：字符串字符串是一个序列(sequence)1234&gt;&gt;&gt; fruit = 'banana'&gt;&gt;&gt; letter = fruit[1]&gt;&gt;&gt; letter'a' 对于大多数人，’banana’ 的第一个字母是 b 而不是 a 。 但是对于计算机科学家，索引是从字符串起点开始的位移量 F(offset) ，第一个字母的位移量就是 0 。 字符串切片字符串的一个片段被称作 切片(slice) 。 选择一个切片的操作类似于选择一个字符：12345&gt;&gt;&gt; s = 'Monty Python'&gt;&gt;&gt; s[0:5]'Monty'&gt;&gt;&gt; s[6:12]'Python' [n:m] 操作符返回从第n个字符到第m个字符的字符串片段，包括第一个，但是不包括最后一个 字符串是不可变的123&gt;&gt;&gt; greeting = 'Hello， world!'&gt;&gt;&gt; greeting[0] = 'J'TypeError: 'str' object does not support item assignment 出现此错误的原因是字符串是 不可变的(immutable) ，这意味着你不能改变一个已存在的字符串。 搜索遍历一个序列并在找到寻找的东西时返回 —— 被称作 搜索(search) 。1234567def find(word， letter): index = 0 while index &lt; len(word): if word[index] == letter: return index index = index + 1 return -1 循环和计数下面的程序计算字母a在字符串中出现的次数：123456word = 'banana'count = 0for letter in word: if letter == 'a': count = count + 1print count 字符串方法字符串提供了可执行多种有用操作的 方法(method) 。方法和函数类似，接受实参并返回一个值，但是语法不同。 例如：upper，不过使用的不是函数语法 upper(word) ， 而是方法的语法 word.upper() 。1234&gt;&gt;&gt; word = 'banana'&gt;&gt;&gt; new_word = word.upper()&gt;&gt;&gt; new_word'BANANA' 点标记法的形式指出方法的名字: upper，以及应用该方法的字符串的名字: word 。空括号表明该方法 不接受实参。这被称作方法调用(invocation) ；在此例中，我们可以说是在 word 上调用 upper 。事实上，有一个被称为 find 的字符串方法， 与我们之前写的函数极其相似：1234&gt;&gt;&gt; word = 'banana'&gt;&gt;&gt; index = word.find('a')&gt;&gt;&gt; index1 in 运算符单词 in 是一个布尔运算符1234def in_both(word1， word2): for letter in word1: if letter in word2: print(letter) 术语表|对象（object）|变量可以引用的东西。现在你将对象和值等价使用||序列（sequence）|一个有序的值的集合，每个值通过一个整数索引标识||元素（item）|序列中的一个值||索引（index）|用来选择序列中元素（如字符串中的字符）的一个整数值。 在Python中，索引从0开始||切片（slice）|以索引范围指定的字符串片段||空字符串（empty string）|一个没有字符的字符串，长度为0，用两个引号表示||不可变 （immutable）|元素不能被改变的序列的性质||遍历（traversal）|对一个序列的所有元素进行迭代，对每一元素执行类似操作||搜索（search）|一种遍历模式，当找到搜索目标时就停止||方法调用(invocation)|执行一个方法的声明| 第十章：列表列表是一个序列在字符串中，每个值都是字符； 在列表中，值可以是任何数据类型。列表中的值称为 元素（element） ，有时也被称为 项（item） 。一个列表在另一个列表中，称为嵌套（nested）列表。1['spam', 2.0, 5, [10, 20]] 列表是可变的和字符串不同的是，列表是可变的。当括号运算符出现在赋值语句的左边时，它就指向了列表中将被赋值的元素。1234&gt;&gt;&gt; numbers = [42, 123]&gt;&gt;&gt; numbers[1] = 5&gt;&gt;&gt; numbers[42, 5] 列表操作123456789101112# 运算符 + 拼接多个列表：&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = [4, 5, 6]&gt;&gt;&gt; c = a + b&gt;&gt;&gt; c[1, 2, 3, 4, 5, 6]# 运算符 * 以给定次数的重复一个列表:&gt;&gt;&gt; [0] * 4[0, 0, 0, 0]&gt;&gt;&gt; [1, 2, 3] * 3[1, 2, 3, 1, 2, 3, 1, 2, 3] 第一个例子重复4次。第二个例子重复了那个列表3次。 列表切片切片（slice） 运算符同样适用于对列表：123&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']&gt;&gt;&gt; t[1:3]['b', 'c'] 如果你省略第一个索引，切片将从列表头开始。如果你省略第二个索引，切片将会到列表尾结束。切片运算符放在赋值语句的左边时，可以一次更新多个元素：12&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']&gt;&gt;&gt; t[1:3] = ['x', 'y'] 列表方法append 添加一个新元素到列表的末端:1234&gt;&gt;&gt; t = ['a', 'b', 'c']&gt;&gt;&gt; t.append('d')&gt;&gt;&gt; t['a', 'b', 'c', 'd'] extend 将接受一个列表作为参数，并将其其中的所有元素添加至目标列表中：12345&gt;&gt;&gt; t1 = ['a', 'b', 'c']&gt;&gt;&gt; t2 = ['d', 'e']&gt;&gt;&gt; t1.extend(t2)&gt;&gt;&gt; t1['a', 'b', 'c', 'd', 'e'] sort 将列表中的元素从小到大进行排序：1234&gt;&gt;&gt; t = ['d', 'c', 'e', 'b', 'a']&gt;&gt;&gt; t.sort()&gt;&gt;&gt; t['a', 'b', 'c', 'd', 'e'] 映射、筛选和归并删除元素如果你知道元素的下标，你可以使用 pop ：123456&gt;&gt;&gt; t = ['a', 'b', 'c']&gt;&gt;&gt; x = t.pop(1)&gt;&gt;&gt; t['a', 'c']&gt;&gt;&gt; x'b' 如果你知道要删除的值（但是不知道其下标），你可以使用 remove ：1234&gt;&gt;&gt; t = ['a', 'b', 'c']&gt;&gt;&gt; t.remove('b')&gt;&gt;&gt; t['a', 'c'] 列表和字符串一个字符串是多个字符组成的序列，一个列表是多个值组成的序列。但是一个由字符组成的列表不同于字符串。 Method Code list字符串转换为字符的列表 &gt;&gt;&gt; s = &#39;spam&#39; &gt;&gt;&gt; t = list(s) &gt;&gt;&gt; t [&#39;s&#39;, &#39;p&#39;, &#39;a&#39;, &#39;m&#39;] split一个字符串分割成一些单词 &gt;&gt;&gt; s = &#39;pining for the fjords&#39;&gt;&gt;&gt; t = s.split()&gt;&gt;&gt; t[&#39;pining&#39;, &#39;for&#39;, &#39;the&#39;, &#39;fjords&#39;] delimiter指定什么字符作为单词之间的分界线 &gt;&gt;&gt; s = &#39;spam-spam-spam&#39;&gt;&gt;&gt; delimiter = &#39;-&#39;&gt;&gt;&gt; t = s.split(delimiter)&gt;&gt;&gt; t[&#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;] join 一个字符串方法，需要在一个分隔符上调用它，并传入一个列表作为参数 &gt;&gt;&gt; t = [&#39;pining&#39;, &#39;for&#39;, &#39;the&#39;, &#39;fjords&#39;]&gt;&gt;&gt; delimiter = &#39; &#39;&gt;&gt;&gt; s = delimiter.join(t)&gt;&gt;&gt; s&#39;pining for the fjords&#39; 术语表 列表（list） 多个值组成的序列 元素（element） 列表（或序列）中的一个值，也称为项 嵌套列表（nested list） 作为另一个列表的元素的列表 累加器（accumulator） 循环中用于相加或累积出一个结果的变量 增量赋值语句（augmented assignment） 一个使用类似 += 操作符来更新一个变量的值的语句 归并（reduce） 遍历序列，将所有元素求和为一个值的处理模式 映射（map） 遍历序列，对每个元素执行操作的处理模式 筛选（filter） 遍历序列，选出满足一定标准的元素的处理模式 对象（object） 变量可以指向的东西。一个对象有数据类型和值 相等（equivalent） 有相同的值 相同（identical） 是同一个对象（隐含着相等） 引用（reference） 一个变量和它的值之间的关联 别名使用 两个或者两个以上变量指向同一个对象的情况 分隔符（delimiter） 一个用于指示字符串分割位置的字符或者字符串 第十一章：字典字典即映射字典包含了一个索引的集合，被称为键（keys） ，和一个值(values)的集合。 一个键对应一个值。这种一一对应的关联被称为 键值对（key-value pair)， 有时也被称为 项（item）。 字典作为计数器集合生成一个字典，将字符作为键，计数器作为相应的值。字母第一次出现时，你应该向字典中增加一项。 这之后，你应该递增一个已有项的值。12345678910111213141516def histogram(s): d = dict() # 生成一个空字典 for c in s: if c not in d: d[c] = 1 else: d[c] += 1 return d&gt;&gt;&gt; h = histogram('brontosaurus')&gt;&gt;&gt; h&#123;'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1&#125;# 重申一遍，字典中的键是无序的。 如果要以确定的顺序遍历字典，你可以使用内建方法 sorted&gt;&gt;&gt; for key in sorted(h): print key, h[key] 字典和列表在字典中，列表可以作为值出现。但是不能是键，字典使用哈希表实现，这意味着键必须是 可哈希的（hashable）。倒转字典的函数：12345678910111213141516def invert_dict(d): inverse = dict() for key in d: val = d[key] if val not in inverse: inverse[val] = [key] else: inverse[val].append(key) return inverse&gt;&gt;&gt; hist = histogram('parrot')&gt;&gt;&gt; hist&#123;'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1&#125;&gt;&gt;&gt; inverse = invert_dict(hist)&gt;&gt;&gt; inverse&#123;1: ['a', 'p', 't', 'o'], 2: ['r']&#125; 备忘录fibonacci 函数，输入的实参越大，函数运行就需要越多时间。 而且运行时间增长得非常快。要理解其原因，请看 fibonacci 的 调用图（call graph） ： 保存已经计算过的值，将它们存在一个字典中。存储之前计算过的值以便今后使用，它被称作 备忘录（memo） 。当 fibonacci 被调用时，它先检查 known 。 如果结果存在，则立即返回。 否则，它必须计算新的值，将其加入字典，并返回它。123456789known = &#123;0:0, 1:1&#125;def fibonacci(n): if n in known: return known[n] res = fibonacci(n-1) + fibonacci(n-2) known[n] = res return res 全局变量术语表 名词 定义 字典（dictionary） 将键映射到对应值的映射 键值对（key-value pair）/项（item） 键值之间映射关系的呈现形式 实现（implementation） 执行计算的一种形式 哈希表（hashtable） 用来实现Python字典的算法 哈希函数（hash function） 哈希表用来计算键的位置的函数 可哈希的（hashable） 具备哈希函数的类型。诸如整数、浮点数和字符串这样的不可变类型是可哈希的；诸如列表和字典这样的可变对象是不可哈希的 逆向查找（reverse lookup） 接受一个值并返回一个或多个映射至该值的键的字典操作 raise语句 专门印发异常的一个语句 调用图（call graph） 绘出程序执行过程中创建的每个栈帧的调用图，其中的箭头从调用者指向被调用者 备忘录（memo） 一个存储的计算值，避免之后进行不必要的计算 标记（flag） 用于说明一个条件是否为真的布尔变量 声明（declaration） 类似global这种告知解释器如何处理变量的语句 第十二章：元组元组是不可变的元组是一组值的序列，其中的值可以是任意类型。元组与列表非常相似。 二者不同之处在于元组的不可变性。1234567891011121314151617# 元组是用逗号隔开一系列值，通常用括号括起来&gt;&gt;&gt; t = ('a', 'b', 'c', 'd', 'e')# 使用单一元素创建元组时，需要在结尾处添加一个逗号&gt;&gt;&gt; t1 = 'a',&gt;&gt;&gt; type(t1)&lt;class 'tuple'&gt;# 将值放置在括号中并不会创建元组&gt;&gt;&gt; t2 = ('a')&gt;&gt;&gt; type(t2)&lt;class 'str'&gt;# 如果实参是一个序列（字符串、列表或者元组），结果将是一个包含序列内元素的元组。&gt;&gt;&gt; t = tuple('lupins')&gt;&gt;&gt; t('l', 'u', 'p', 'i', 'n', 's') 关系型运算符也适用于元组和其他序列：12&gt;&gt;&gt; (0, 1, 2000000) &lt; (0, 3, 4)True 元组赋值12345678910# 两个变量互换值&gt;&gt;&gt; a, b = b, a# 将一个电子邮箱地址分成用户名和域名&gt;&gt;&gt; addr = 'monty@python.org'&gt;&gt;&gt; uname, domain = addr.split('@')&gt;&gt;&gt;&gt; uname'monty'&gt;&gt;&gt; domain'python.org' 元组作为返回值内建函数 divmod 接受两个实参，返回包含两个值的元组：商和余数123456&gt;&gt;&gt; t = divmod(7, 3)&gt;&gt;&gt; t(2, 1)&gt;&gt;&gt;def min_max(t):return min(t), max(t) 可变长度参数元组函数可以接受可变数量的参数。 以 * 开头的形参将输入的参数汇集到一个元组中。1234&gt;&gt;&gt; def printall(*args): print(args)&gt;&gt;&gt; printall(1, 2.0, '3')(1, 2.0, '3') 与汇集相对的，是分散（scatter）。如果你有一个值序列，想将其作为多个参数传递给一个函数，你可以使用运算符 *。1234567&gt;&gt;&gt; t = (7, 3)&gt;&gt;&gt; divmod(t)TypeError: divmod expected 2 arguments, got 1# 但是如果你将这个元组分散，它就可以被传递进函数：&gt;&gt;&gt; divmod(*t)(2, 1) 列表和元组zip 是一个内建函数，可以接受将两个或多个序列组，并返回一个元组列表，其中每个元组包含了各个序列中相对位置的一个元素。这个函数的名称来自名词拉链(zipper)，后者将两片链齿连接拼合在一起。12345678910111213141516171819202122&gt;&gt;&gt; s = 'abc'&gt;&gt;&gt; t = [0, 1, 2]&gt;&gt;&gt; zip(s, t)&lt;zip object at 0x7f7d0a9e7c48&gt;# 输出的结果是一个 zip 对象&gt;&gt;&gt; for pair in zip(s, t): print(pair)('a', 0)('b', 1)('c', 2)# 通过 zip 对象创建一个列表&gt;&gt;&gt; t=list(zip(s, t))&gt;&gt;&gt; t[('a', 0), ('b', 1), ('c', 2)]&gt;&gt;&gt; for letter, number in t: print(number, letter)0 a1 b2 c 如果需要遍历一个序列的元素以及其索引号，您可以使用内建函数 enumerate ：12for index, element in enumerate('abc'): print(index, element) 术语表 名词 定义 元组（tuple） 一个由多个元素组成的不可变序列 元组赋值（tuple assignment） 一种赋值方式，等号右侧为一个序列，等号左侧为一个变量组成的元组。右侧的表达式先求值，然后其元素被赋值给左侧元组中对应的变量 汇集（gather） 组装可变长度实参元组的一种操作 分散（scatter） 将一个序列变换成一个参数列表的操作 zip 对象 使用内建函数 zip 所返回的结果；它是一个可以对元组序列进行迭代的对象 迭代器（iterator） 一个可以对序列进行迭代的对象，但是并不提供列表操作符和方法 数据结构（data structure） 一个由关联值组成的的数据集合，通常组织成列表、字典、元组等 形状错误（shape error） 由于某个值的形状出错，而导致的错误；即拥有错误的类型或大小 第十三章：案例研究：数据结构选择词频分析随机数伪随机数不是真正的随机数，因为它们由一个确定性的计算生成 randdom模块 参数解释 randomx = random.random() 返回一个 0.0 到 1.0 之间的随机浮点数（包括 0.0 ，但是不包括 1.0 ） randintrandom.randint(5, 10) 接受参数 low 和 high ， 返回一个 low 和 high 之间的整数（两个都包括） choicerandom.choice(t) 从一个序列t中随机选择一个元素 待续 第十四章：文件读取和写入要写入一个文件，你必须在打开文件时设置第二个参数来为 w 模式：1234&gt;&gt;&gt; fout = open('output.txt', 'w')&gt;&gt;&gt; line1 = "This here's the wattle,\n"&gt;&gt;&gt; fout.write(line1)&gt;&gt;&gt; fout.close() 如果该文件已经存在，那么用写入模式打开它将会清空原来的数据并从新开始。完成文件写入后，你应该关闭文件。如果你不关闭这个文件，程序结束时它才会关闭。 格式化运算符write的参数必须是字符串，所以如果想要在文件中写入其它值，我们需要先将它们转换为字符串。使用 格式化运算符（format operator） ，即 % 。作用于整数时，% 是取模运算符，而当第一个运算数是字符串时，% 则是格式化运算符。12&gt;&gt;&gt; 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')'In 3 years I have spotted 0.1 camels.' 文件名和路径 os模块(operating system) 提供了操作文件和目录的函数 os.getcwd 返回当前目录的名称current working directory os.path.abspath 绝对路径（absolute path） os.path.exists 检查一个文件或者目录是否存在 os.path.isdir 检查它是否是一个目录 os.path.isfile 检查它是否是一个文件 os.listdir 返回给定目录下的文件列表 遍历一个目录，打印所有文件的名字，并且针对其中所有的目录递归的调用自身：1234567def walk(dirname): for name in os.listdir(dirname): path = os.path.join(dirname, name) if os.path.isfile(path): print(path) else: walk(path) 数据库举个例子，我接下来创建建一个包含图片文件标题的数据库。 dbm模块 提供了一个创建和更新数据库文件的接口 db = dbm.open(‘captions’, ‘c’) 模式 ‘c’ 代表如果数据库不存在则创建该数据库 db[‘cleese.png’] = ‘Photo of John Cleese.’ 创建一个新项时，dbm 将更新数据库文件 db[‘cleese.png’] 访问某个项时，dbm 将读取文件 b’Photo of John Cleese.’ db.close() 操作后需要关闭文件 一些字典方法，例如 keys 和 items ，不适用于数据库对象，但是 for 循环依然适用：12for key in db: print(key, db[key]) 序列化dbm 的一个限制在于键和值必须是字符串或者字节。pickle模块 能将几乎所有类型的对象转化为适合在数据库中存储的字符串，以及将那些字符串还原为原来的对象。123456789101112# pickle.dumps读取一个对象作为参数，并返回一个字符串表示：&gt;&gt;&gt; import pickle&gt;&gt;&gt; t = [1, 2, 3]&gt;&gt;&gt; pickle.dumps(t)b'\x80\x03]q\x00(K\x01K\x02K\x03e.'# pickle.loads （“load string”）可以重建对象：&gt;&gt;&gt; t1 = [1, 2, 3]&gt;&gt;&gt; s = pickle.dumps(t1)&gt;&gt;&gt; t2 = pickle.loads(s)&gt;&gt;&gt; t2[1, 2, 3] 你可以使用 pickle 将非字符串对象存储在数据库中。 事实上，这个组合非常常用，已经被封装进了模块 shelve 中。 管道???编写模块任何包含 Python 代码的文件，都可以作为模块被导入。作为模块的程序通常写成以下结构：12if __name__ == '__main__': print(linecount('wc.py')) _name_是一个在程序开始时设置好的内建变量。 如果程序以脚本的形式运行，__name__ 的值为 __main__ ，这时其中的代码将被执行。否则当被作为模块导入时，其中的代码将被跳过。 调试当你读写文件时，可能会遇到空白带来的问题。内建函数 repr 可以用来解决这个问题。它返回一个该对象的字符串表示。对于空白符号，它将用反斜杠序列表示：123456&gt;&gt;&gt; s = '1 2\t 3\n 4'&gt;&gt;&gt; print(s)1 2 3 4&gt;&gt;&gt; print(repr(s))'1 2\t 3\n 4' 术语表 名词 定义 格式化运算符（format operator） % 读取一个格式化字符串和一个元组，生成一个包含元组中元素的字符串，按照格式化字符串的要求格式化 格式化字符串（format string） 一个包含格式化序列的字符串，和格式化运算符一起使用 格式化序列（format sequence） 格式化字符串中的一个字符序列，例如%d，指定了一个值的格式 捕获（catch） 为了防止程序因为异常而终止，使用 try 和 except 语句来捕捉异常 管道对象（pipe object） 一个代表某个正在运行的程序的对象，允许一个 Python 程序去运行命令并得到运行结果 第十五章：类和对象程序员自定义类型我们已经使用过了许多 Python 的内置类型； 现在我们要定义一个新类型。举个例子，我们来创建一个叫做 Point 的类型，代表二维空间中的一个点(x,y)。在 Python 中，有几种表示点的方法： 我们可以将坐标存储在两个独立的变量，x和y中。 我们可以将坐标作为一个列表或者元组的元素存储。 我们可以创建一个新类型将点表示为对象。 程序员自定义类型( A programmer-defined type )也被称作类（class）。 定义一个叫做 Point 的类将创建了一个类对象（class object）:123456789&gt;&gt;&gt; class Point: &quot;&quot;&quot;Represents a point in 2-D space.&quot;&quot;&quot; # 主体部分是文档字符串，用来解释这个类的用途。&gt;&gt;&gt; Point&lt;class &apos;__main__.Point&apos;&gt; # 由于 Point 是定义在顶层的，所以它的“全名”是__main__.Point。&gt;&gt;&gt; blank = Point()&gt;&gt;&gt; blank&lt;__main__.Point object at 0xb7e9d3ac&gt; 类对象就像是一个用来创建对象的工厂。创建一个新对象的过程叫做实例化（instantiation），这个新对象叫做这个类的一个实例（instance）。 属性你可以使用点标记法向一个实例进行赋值操作：12&gt;&gt;&gt; blank.x = 3.0&gt;&gt;&gt; blank.y = 4.0 变量 blank 引用了一个 Point 类，这个类拥有了两个属性。 每个属性都引用了一个浮点数。 矩形为了描述一个矩形的位置和大小，你需要设计哪些属性呢？ 至少有两种可能的设计： 你可以指定矩形的一个角（或是中心）、宽度以及长度。 你可以指定对角线上的两个角。 这个时候还不能够说明哪个方法优于哪个方法。我们先来实现前者。下面是类的定义：12345class Rectangle: &quot;&quot;&quot;Represents a rectangle. attributes: width, height, corner. &quot;&quot;&quot; 文档字符串中列出了属性：width 和 height 是数字； corner是一个 Point 对象，代表左下角的那个点。为了描述一个矩形，你需要实例化一个 Rectangle 对象，并且为它的属性赋值：表达式 box.corner.x 指， 前往 box 所引用的对象，找到叫做 corner 的属性； 然后前往 corner 所引用的对象，找到叫做 x 的属性。123456box = Rectangle()box.width = 100.0box.height = 200.0box.corner = Point()box.corner.x = 0.0box.corner.y = 0.0 对象图展示了这个对象的状态。 一个对象作为另一个对象的属性叫做嵌套（embedded）。 术语表 名词 定义 类（class） 一种程序员自定义的类型。类定义创建了一个新的类对象 类对象（class object） 包含程序员自定义类型的细节信息的对象。类对象可以被用于创建该类型的实例 实例（instance） 属于某个类的对象 实例化（instantiate） 创建新的对象 属性（attribute） 和某个对象相关联的有命名的值 嵌套对象（embedded object） 作为另一个对象的属性存储的对象 浅复制（shallow copy） 在复制对象内容的时候，只包含嵌套对象的引用，通过 copy 模块的copy函数实现 深复制（deep copy） 在复制对象内容的时候，既复制对象属性，也复制所有嵌套对象及其中的所有嵌套对象，由 copy 模块的deepcopy函数实现 对象图（object diagram） 展示对象及其属性和属性值的图 第十六章：类和函数术语表 名词 定义 原型和补丁（prototype and patch） 一种开发方案，编写一个程序的初稿，测试，发现错误时修正它们 设计开发（designed development） 一种开发方案，需要对问题有更高层次的理解，比增量开发或原型开发更有计划性 纯函数（pure function） 一种不修改任何作为参数传入的对象的函数。大部分纯函数是有返回值的（fruitful） 修改器（modifier） 一种修改一个或多个作为参数传入的对象的函数。大部分修改器没有返回值；即返回 None 函数式编程风格（functional programming style） 一种程序设计风格，大部分函数为纯函数 不变式（invariant） 在程序执行过程中总是为真的条件 断言语句（assert statement） 一种检查条件是否满足并在失败的情况下抛出异常的语句 第十七章：类和方法 第十九章：进阶小技巧条件表达式1234567if x &gt; 0: y = math.log(x)else: y = float('nan')# 我们可以使用 条件表达式 简化这个语句：y = math.log(x) if x &gt; 0 else float('nan') 列表推导式123456789def capitalize_all(t): res = [] for s in t: res.append(s.capitalize()) return res# 我们可以使用 列表推导式 简化该函数：def capitalize_all(t): return [s.capitalize() for s in t] 生成器表达式生成器表达式与列表推导式类似，但是使用的是圆括号，而不是方括号：123&gt;&gt;&gt; g = (x**2 for x in range(5))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x7f4c45a786c0&gt; any 和 all12&gt;&gt;&gt; any(letter == 't' for letter in 'monty')True Python还提供了另一个内建函数 all，如果序列中的每个元素均为 True 才会返回 True 。 集合返回不在 d2 中但在 d1 里的键组成的字典。12345678910def subtract(d1, d2): res = dict() for key in d1: if key not in d2: res[key] = None return res# Python提供了另一个叫做集合的内建类型，它的行为类似没有值的字典键集合。def subtract(d1, d2): return set(d1) - set(d2) 计数器计数器（Counter）类似集合，区别在于如果某个元素出现次数超过一次，计数器就会记录其出现次数。1234&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; count = Counter('parrot')&gt;&gt;&gt; countCounter(&#123;'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1&#125;) 计数器的行为与字典有很多相似的地方：它们将每个键映射至其出现的次数。 defaultdict? 第二十章：调试语法错误 确保你没有使用 Python 的关键字作为变量名称。 检查你在每个复合语句首行的末尾都加了冒号，包括for，while，if，和 def 语句。 确保代码中的字符串都有匹配地引号。确保所有的引号都是“直引号”，而不是“花引号”。 如果你有带三重引号的多行字符串，确保你正确地结束了字符串。一个没有结束的字符串会在程序的末尾产生 invalid token 错误，或者它会把剩下的程序看作字符串的一部分，直到遇到下一个字符串。 一个没有关闭的操作符(， { 以及 [使得 Python 把下一行继续看作当前语句的一部分。通常下一行会马上提示错误消息。 检查条件语句里面的 == 是不是写成了 = 。 确保每行的缩进是符合要求。Python 能够处理空格和制表符，但是如果混用则会出错。避免该问题的最好方法是使用一个了解 Python 语法、能够产生一致缩进的纯文本编辑器。 如果代码中包含有非ASCII字符串（包括字符串和注释），可能会出错，尽管 Python 3 一般能处理非ASCII字符串。从网页或其他源粘贴文本时，要特别注意。 第二十一章：算法分析算法分析的实际目的是预测不同算法的性能，用于指导设计决策。 增长量级假设你已经分析了两个算法，并能用输入计算量的规模表示它们的运行时间： 若算法 A 用 100n+1 步解决一个规模为 n 的问题；而算法 B 用 n^2+n+1 步。 下表列出了这些算法对于不同问题规模的运行时间： Input Run time of Run time of size Algorithm A Algorithm B 10 1001 111 100 10 001 10 101 1 000 100 001 1 001 001 10 000 1 000 001 &gt;10^10 增长量级(order of growth)是一个函数集合，集合中函数的增长行为被认为是相当的。 例如2n、100n和n+1属于相同的增长量级，可用 大O符号(Big-Oh notation) 写成O(n)， 而且常被称作 线性级 (linear)，因为集合中的每个函数随着n线性增长。 下表列出了算法分析中最通常的一些增长量级，按照运行效率从高到低排列 。 Order of Growth Name 名称 O(1) constant 常数级 O(logbn) logarithmic 对数级 O(n) linear 线性级 O(nlogbn) linearithmic 线性对数级 O(n2) quadratic 二次方级 O(n3) cubic 三次方级 O(cn) exponential 指数级 Python基本运算操作分析在 Python 中，大部分算术运算的开销是常数级的；索引操作 — 在序列或字典中读写元素 — 的增长量级也是常数级的，和数据结构的大小无关。 搜索算法分析搜索 (search)算法，接受一个集合以及一个目标项，并判断该目标项是否在集合中，通常返回目标的索引值。最坏的情况下， 它不得不遍历全部集合，所以运行时间是线性的。序列的 in 操作符使用线性搜索；字符串方法 find 和 count 也使用线性搜索。如果元素在序列中是排序好的，你可以用 二分搜素 (bisection search) ，它的增长量级是 O(logn) 。 二分搜索比线性搜索快很多，但是它要求已排序的序列，因此使用时需要做额外的工作。 哈希表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习资源]]></title>
      <url>%2F2017%2F04%2F10%2FPython-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%2F</url>
      <content type="text"><![CDATA[学习教程基础教程 笨办法学 Python 中文版 → http://www.kancloud.cn/wizardforcel/lpthw/92438 这本书绝对是最简单的学习 Python 的方法。你会真实地感受到自己的学习进程，一步步的获取新的知识。 Online Python Tutor：Python 初学者的好帮手 Online Python Tutor 是由 Philip Guo 开发的一个免费教育工具，可帮助学生攻克编程学习中的基础障碍，理解每一行源代码在程序执行时在计算机中的过程。 Learn Python Programming @ Codecademy 在这个 Codecademy 的课程中你将会学到如何用文件，如何使用循环。什么是函数以及他们能用来做什么。这些都是很基础的，但是对初学者很 有好的东西。当需要帮助时有一个交流的论坛，但通常所有东西都能被理解. 目前完成61%，找答案比较费时，转战[Think Python]教程。 简明 Python 教程 非常像 LPTHW，但是在如何制定你的完美学习计划并实施，以及如何开始第一步上 提供了更深的引导，而不会让你丧失自信心。对于那些想学 Python 的人来说它被认为是 最好的初学者教程之一，当然你要先看看前几章，看看自己是否喜欢它的写作风格. Learning with Python How to Think Like a Computer Scientist-Learning with Python Think Python 中文版 → http://codingpy.com/books/thinkpython2/ Think Python 是一个面向 Python 初学者的一个指南。它从编程的基本概念教起，而且它很仔细地定义了所有的术语当他们第一次用到时，并且很有逻辑性地展现新的概念。像递归和面向对象这样大一点的知识块被分成了一系列更小的步骤，穿插于课程几个章节. 已经完成全部课程，部分习题未做。 网站资源 编程派 - codingpy 打造数据科学作品集1：用数据讲故事 link 打造数据科学作品集2：搭建一个数据科学博客 link 打造数据科学作品集3：从机器学习项目开始 link 打造数据科学作品集4：数据科学家如何找到心仪工作？ link 玩蛇网 — iplaypy 个人博客 我爱自然语言处理 Python 正则表达式操作指南 扩展包 SciPy.orgSciPy是一个开源的Python算法库和数学工具包。包括了以下这些核心包: 核心包 定义 功能 NumPy Base N-dimensional array package 提供函数、线性代数、傅里叶变换和随机数，整合将C/c++和Fortran代码的工具 SciPy library Fundamental library for scientific computing 构成SciPy堆栈的核心包，提供了许多高效的数值程序：数值积分和最优化 Matplotlib Comprehensive 2D Plotting 绘图库，提供了一整套和matlab相似的命令API，十分适合交互式地进行制图 pandas Data structures &amp; analysis 提供高性能、易于使用的数据结构和数据分析(再加工)工具 Sympy Symbolic mathematics 一个全功能的计算机代数系统(CAS) IPython Enhanced Interactive Console 一个强大的交互式shell，支持交互式数据可视化和GUI工具包的使用 scikit-learn 建立在NumPy、SciPy matplotlib上，高效的数据挖掘和数据分析工具，多种回归，分类，聚类，向量机，朴素贝叶斯，逻辑回归 Pattern Python的挖掘模块，拥有以下工具： 数据挖掘：包括网络服务（Google，Twitter，Wikipedia），网络蜘蛛，HTML DOM解析 自然语言处理 机器学习 网络分析 mlpy a high-performance Python library for predictive modeling Statsmodels 统计建模和计量经济学工具包，包括一些描述统计、统计模型估计和推断。 Scrapy 爬虫教程 NLTK 自然语言工具箱（Natural Language Toolkit）是一个基于Python语言的类库，它也是当前最为流行的自然语言编程与开发工具。 Theano 深度学习 - 工具对比 Unofficial Windows Binaries for Python Extension Packages // 非官方的Python扩展包(Windows二进制文件) 案例 用Scrapy爬虫下载图片(豆瓣电影图片)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Packages-R包汇总（更新中）]]></title>
      <url>%2F2017%2F04%2F06%2FPackages-R%E5%8C%85%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[加载/当前R包的清单12&gt; getOption(&quot;defaultPackages&quot;)&gt; (packages) 实现ggplot2的图形界面操作 RcmdrPlugin.KMggplot2包是Rcmdr包的一个插件。它通过集成ggplot2包可以实现Kamplan-Meier图，直方图，Q-Q 图，箱线图，误差条图，散点图，线图，饼图，条形图，等高线图，分布图等的“鼠标化”操作。 交互数据可视化rCharts包：该包直接在R中生成基于D3的Web界面。123&gt; install.packages(&quot;devtools&quot;)&gt; require(devtools)&gt; install_github(&apos;rCharts&apos;, &apos;ramnathv&apos;) 量化分析quantmod包12&gt; install.packages(&quot;quantmod&quot;)&gt; require(quantmod) 绘制中国地图12&gt; install.packages(&quot;maps&quot;)&gt; library(&quot;maps&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ggplot2的图形语法（待续）]]></title>
      <url>%2F2017%2F04%2F06%2Fggplot2%E7%9A%84%E5%9B%BE%E5%BD%A2%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[安装包ggplot2的核心理念是将绘图与数据分离，数据相关的绘图与数据无关的绘图分离。按图层作图，图层(layer)之间是通过“+”来粘合构图的。想使用ggplot之前，需要先安装相应的包：（镜像选择china:beijing） 12install.packages(&quot;ggplot2&quot;) # 在R中安装ggplot2包library(ggplot2) # 载入ggplot2包 图形部件数据(data) 在ggplot2中, 所接受的数据集必须为数据框data.frame格式，这种格式带来的好处是数据易于存储, 也能在保留原有的绘图参数下, 用%+%方便地变更已有数据集。用mtcars.c替换mtcars12mtcars.c &lt;- transform(mtcars, mpg = mpg^2)p %+% mtcars.c 而ggplot2进行数据分组时必须根据行, 而不能根据列，变量不在是放在各个列上, 而是拍成一列, 每一个变量都分别占其中的几行, 这样就能方便的对每个变量进行分组。reshape2中的函数可以融合(melt)和重铸(cast)数据框中的数据。 12install.packages(&quot;reshape2&quot;) #在R中安装reshape2包library(reshape2) #载入reshape2包 映射(mapping) 映射是将一个变量中离散或连续的数据与一个图形属性中以不同的参数来相互关联, 而设定能够将这个变量中所有的数据统一为一个图形属性。 aes()函数是ggplot2中的映射函数 12p&lt;- ggplot(data= mtcars, mapping= aes(x= wt, y= hp))p+ geom_point(color= “blue”) #设定散点的颜色为蓝色 分组(group)也是ggplot2种映射关系的一种 1p &lt;-ggplot(data=mtcars, mapping=aes(x=wt, y=hp, group=factor(gear)))+geom_line() 图层(layer) ggplot2中的图层：每个图层可以代表一个图形组件, 例如下面要介绍的几何对象、统计变换等图形组件, 这些组件以图层的方式叠加在一起构成一个绘图的整体，在每个图层中的图形组件又可以分别设定数据、映射或其他相关参数, 因此组件之间又是具有相对独立性的。 几何对象(geom)统计变换(stat)统计变换即对数据进行统计变化, 通常以某种方式对数据信息进行汇总, 例如通过stat_smooth()添加光滑曲线。 标度(scale)标度控制着数据到图形属性的映射, 更重要的一点是标度将我们的数据转化为视觉上可以感知的东西, 如大小、颜色、位置和形状。所以通过标度可以修改坐标轴和图例的参数。 坐标系(coord)分面(facet)主题(theme)主题系统控制着图形中的非数据元素外观, 它不会影响几何对象和标度等数据元素。主题修改是一个对绘图精雕细琢的过程, 主要对标题、坐标轴标签、图例标签等文字调整, 以及网格线、背景、轴须的颜色搭配。 存储和输出(ggsave)ggplot2支持eps矢量图输出, 其他可以支持的格式包括png, jpg, pdf等, 并通过ggsave可以方便的进行修改。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[时间序列的分位数回归（待续）]]></title>
      <url>%2F2017%2F04%2F06%2F%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%88%86%E4%BD%8D%E6%95%B0%E5%9B%9E%E5%BD%92%2F</url>
      <content type="text"><![CDATA[复合分位数回归 估计回归系数的传统方法是最小二乘法，最小二乘法对于误差项的要求是非常严苛的，在实际问题中，数据往往会出现 尖峰厚尾 等特征，或者是存在明显的异方差情况，这时候若使用LS方法对回归系数进行估计，其稳健性是很差的。分位数回归有效的解决了上述问题，符合分位数回归是分位数回归的一种更一般性的推广。【尖峰厚尾】 金融数据的尖峰厚尾特征是相比较标准正态分布来说的，标准正态分布的偏度为0，峰度为3，通常做实证分析时，会假设金融数据为正态分布，这样方便建模分析，但是实证表明，很多数据并不符合正态分布，而更像尖峰厚尾，就是峰度比3大，两边的尾巴比正态分布厚，没有下降得这么快。厚尾分布主要是出现在金融数据中，例如证券的收益率。 从图形上说，较正态分布图的尾部要厚，峰处要尖。直观些说，就是这些数据出现极端值的概率要比正态分布数据出现极端值的概率大。因此，不能简单的用正态分布去拟合这些数据的分布，从而做一些统计推断。一般来说，通过实证分析发现，自由度为5或6的t分布拟合的较好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据科学1.2 数据结构（待续）]]></title>
      <url>%2F2017%2F03%2F30%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A61.2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[绪论数据结构基本概念数据项：一个数据元素由若干数据项组成数据元素：组成数据对象的基本单位数据对象：性质相同的数据元素的集合（类似于数组一般） 数据结构：计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。数据结构例子 集合结构：数据元素之间除了同属于一个集合的关系 线性结构：数据元素之间存在着一对一的线性关系 树状结构：数据元素之间存在着一对多的层次关系 图状结构或网状结构：元素之间存在着多对多的任意关系]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo系列]]></title>
      <url>%2F2017%2F03%2F29%2FHexo%E7%B3%BB%E5%88%97%2F</url>
      <content type="text"><![CDATA[本文旨在帮助刚接触 Github 新手，想利用 Github 来创建自己的站点、个人博客等。使用 Hexo + Next 搭建静态博客 Hexo 安装完之后，主题的初始化格式非常简单。next主题的作者提供了一个非常好的方式，就是 custom 文件，这个文件就是用来让用户在里面添加自己的样式去覆盖主题原有的样式。推荐以下3篇个性化设置文章。 Hexo搭建博客的个性化设置一Hexo搭建博客的个性化设置二Hexo搭建博客的个性化设置三Hexo 3.1.1 静态博客搭建指南]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫：Scrapy框架安装配置]]></title>
      <url>%2F2017%2F03%2F10%2FPython-%E7%88%AC%E8%99%AB%E4%B9%8BScrapy%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[本篇文章中Python的安装是基于window平台，安装Scrapy之前确保已经安装好下列程序: 安装Python 安装过程见→ python初级教程：入门详解 在命令行中输入 python –version，如果没有提示错误，则安装成功。 安装pywin32 在windows下，必须安装pywin32，安装地址： http://sourceforge.net/projects/pywin32/ http://www.softpedia.com/get/Programming/Other-Programming-Files/PyWin32.shtml#download 下载直接双击安装，安装完毕之后在python命令行下输入import win32com,如果没有提示错误，则证明安装成功! 安装pip pip是用来安装其他必要包的工具，首先下载get-pip.py 下载好之后，选中该文件夹所在路径，执行命令python get-pip.py 执行命令后便会安装好pip，同时，它帮你安装了setuptools 安装完了之后在命令行执行pip --version 安装完后若提醒版本低，可进行更新python -m pip install --update pip pip is already installed if you’re using Python 2 &gt;=2.7.9 or Python 3 &gt;=3.4 安装pyOPENSSL 在Windows下，是没有预装pyOPENSSL的，而在Linux下是已经安装好的。 安装地址：https://launchpad.net/pyopenssl (下载pyOpenSSL-0.11.winxp32-py2.7) 如果出现了Python Version 2.7 required which was not found in the registry错误！ 解决方法：新建一个register.py 文件，把以下代码贴进去，保存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# script to register Python 2.0 or later for use with win32all# and other extensions that require Python registry settings## written by Joakim Loew for Secret Labs AB / PythonWare## source:# http://www.pythonware.com/products/works/articles/regpy20.htm# import sys from _winreg import * # tweak as necessaryversion = sys.version[:3]installpath = sys.prefix regpath = "SOFTWARE\\Python\\Pythoncore\\%s\\" % (version)installkey = "InstallPath"pythonkey = "PythonPath"pythonpath = "%s;%s\\Lib\\;%s\\DLLs\\" % ( installpath, installpath, installpath) def RegisterPy(): try: reg = OpenKey(HKEY_CURRENT_USER, regpath) except EnvironmentError as e: try: reg = CreateKey(HKEY_CURRENT_USER, regpath) SetValue(reg, installkey, REG_SZ, installpath) SetValue(reg, pythonkey, REG_SZ, pythonpath) CloseKey(reg) except: print "*** Unable to register!" return print "--- Python", version, "is now registered!" return if (QueryValue(reg, installkey) == installpath and QueryValue(reg, pythonkey) == pythonpath): CloseKey(reg) print "=== Python", version, "is already registered!" return CloseKey(reg) print "*** Unable to register!" print "*** You probably have another Python installation!" if __name__ == "__main__": RegisterPy() 在cmd 中运行python脚本 双击安装 pyOpenSSL-0.11.winxp32-py2.7 安装 lxml第一种办法： lxml的详细介绍 link ，是一种使用 Python 编写的库，可以迅速、灵活地处理 XML 直接执行如下命令pip install lxml就可完成安装 如果提示 Microsoft Visual C++库没安装，则 link 下载支持的库。 可能报错： 第二种办法：步骤1：安装wheel，cmd命令行运行：pip install wheel步骤2：在这里http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml下载对应的.whl文件Ctrl + F，输入lxml，找到下面这段，cp后面是Python的版本号，27表示2.7。 lxml‑3.6.4‑cp27‑cp27m‑win32.whllxml‑3.6.4‑cp27‑cp27m‑win_amd64.whllxml‑3.6.4‑cp34‑cp34m‑win32.whllxml‑3.6.4‑cp34‑cp34m‑win_amd64.whllxml‑3.6.4‑cp35‑cp35m‑win32.whllxml‑3.6.4‑cp35‑cp35m‑win_amd64.whllxml‑3.6.4‑cp36‑cp36m‑win32.whllxml‑3.6.4‑cp36‑cp36m‑win_amd64.whl 步骤3：进入.whl所在的文件夹，执行命令pip install 带后缀的完整文件名即可完成安装pip安装报错：is not a supported wheel on this platform解决方法：在shell中输入import pip; print(pip.pep425tags.get_supported())可以获取到pip支持的文件名还有版本12345678import pip; print(pip.pep425tags.get_supported())[('cp27', 'none', 'win_amd64'), ('cp27', 'none', 'any'), ('cp2', 'none', 'any'), ('cp26', 'none', 'any'), ('cp25', 'none', 'any'), ('cp24', 'none', 'any'), ('cp23', 'none', 'any'), ('cp22', 'none', 'any'), ('cp21', 'none', 'any'), ('cp20', 'none', 'any'), ('py27', 'none', 'any'), ('py2', 'none', 'any'), ('py26', 'none', 'any'), ('py25', 'none', 'any'), ('py24', 'none', 'any'), ('py23', 'none', 'any'), ('py22', 'none', 'any'), ('py21', 'none', 'any'), ('py20', 'none', 'any')] 可以发现上面下载的文件名格式是不支持的，修改为：lxml-3.7.3-cp27-none-win_amd64.whl即可成功安装。 安装Scrapy 最后就是激动人心的时刻啦，上面的铺垫做好了，我们终于可以享受到胜利的果实啦！ 执行如下命令pip install Scrapy pip 会另外下载其他依赖的包，这些就不要我们手动安装啦，等待一会，大功告成！ 验证安装，输入 Scrapy 创建项目 scrapy startproject phone 发生问题： 问题原因：twist版本问题，twist版本高于需要的 输入pip freeze查看twist版本，用pip install twisted==13.1.0 替代更高的版本 Scrapy入门教程 Scrapy 1.0 中文文档 — 这是一本步骤详细的说明书。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python安装]]></title>
      <url>%2F2017%2F03%2F09%2FPython-%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[文章转载 → Python初级教程 , 文章篇幅太长，下文做了精简。 本文是针对Python的初学者，从无到有的介绍Python语言如何入门，主要包括了：Python的简介，如何下载Python，如何安装Python，如何使用终端、Shell，IDE等各种开发环境进行Python开发，Python中的语法和基本知识、概念和逻辑，以及继续深入学习Python的方法，另外还整理一些值得参考的资料。 安装Python1. Python官网不是太稳定，对于国内开发者来说，时不时会出现无法访问的情况。可以选择国内的镜像进行下载。 官网上的下载地址 国内的镜像 http://www.python.org/ftp/python/http://python.org/getit/releases/ http://mirrors.sohu.com/python/ 2. Python有2.x版本和3.x版本的区别。对于初学者，推荐先用Python 2.x版本的。 总结Python2(Python 2.x版本）和Python3（Python 3.x版本）之间的区别 如何在Windows系统中安装Python 开发环境 针对初学者，建议使用windows的cmd下，去运行python脚本。目的很明确：很多东西的学习，其本质上，都是需要一个循序渐进的过程的，学习Python语言同样如此。在没有学会走路，即如何搞懂Windows的cmd下运行Python脚本，就想学会跑了，即直接利用Python的IDE，包括shell和第三方开发环境，结果就是，很多东西，还是不明白到底是为什么，理解的不透彻。而当Python的基本知识，基本开发流程熟悉了之后，再建议你去使用第三方的Python的IDE。 先：Windows的cmd + Notepad++再：选用某个IDE，比如PyScripter，Ulipad，Eclipse+PyDev等。 使用问题在window的cmd中运行python结果却调用了文本编辑器去打开了，而不是去调用Python解析器去运行python文件 解决办法：修改后缀为.py文件的打开方式，设置为python]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分类和预测]]></title>
      <url>%2F2017%2F03%2F03%2F%E5%88%86%E7%B1%BB%E5%92%8C%E9%A2%84%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[分类：预测类对象的分类标号，根据训练数据集和类标号属性，构建模型来分类现有数据，并用来分类新数据。银行需要弄清楚那些贷款申请者是安全的，哪些是有风险的。预测：建立连续函数值模型，比如预测空缺值，或者预测顾客在某项活动中的花费。银行需要预测贷给某个顾客多少钱是安全的，预测一个连续值函数或有序值，常用方法是回归分析。 典型应用：欺诈检测 市场定位 医疗诊断 准备分类和预测的数据数据预处理数据清理通过填写空缺值，平滑噪声数据，识别删除孤立点，并解决不一致来清理数据。 空缺值 噪声数据(数据平滑技术) 1. 分箱 2. 聚类 3. 回归 - 忽略元组- 人工填写空缺值- 使用固定值- 使用属性平均值- 使用最有可能值 - 箱的深度：表示不同的箱里有相同个数的数据- 箱的宽度：每个箱值的取值区间是个常数- 平滑的办法：① 按箱平均值平滑② 按箱中值平滑③ 按箱边界值平滑 - 每个簇中的数据用其中心值代替- 忽略孤立点- 先通过聚类等办法找出孤立点。- 人工再审查这些孤立点 - 通过构造函数来符合数据变化的趋势，这样可以用一个变量预测另一个变量。① 线性回归② 多线性回归 数据清洗 格式标准化 异常数据清除 错误纠正 重复数据清除 数据变换 平滑 聚集 数据概化 规范化 属性构造 数据立方体聚集 最小 最大规范化 有给定的属性构造和添加新的属性，以帮助提高精度和对高纬度数据结构的理解 数据归约 数据聚集 维归约 数据压缩 数值归约 - 删除不相关属性属性子集选择 - 小波变换- 主要成分分析 - 回归和对数线性模型线性回归对数线性模型- 直方图等宽等深V-最优maxDiff 相关分析 在分类和回归之前进行，它试图识别与分类和回归过程显著相关的属性。 属性子集选择通过删除不相关或冗余的属性减少数据量。属性子集选择的目标是找出最小属性集，使得数据类的概率分布尽可能地接近使用所有属性得到的原分布。 向前选择 向后删除 决策树归纳 初始属性集：{A1，A2，A3，A4，A5，A6}初始化归约集：{ }=&gt; {A1}=&gt; {A1，A4}=&gt; 归约后的属性集：{A1，A4，A6} 初始属性集：{A1，A2，A3，A4，A5，A6}=&gt; {A1，A3，A4，A5，A6} =&gt; {A1，A4，A5，A6}=&gt; 归约后的属性集：{A1，A4，A6} 初始属性集：{A1，A2，A3，A4，A5，A6}当决策树归纳用于属性子集选择时，由给定的数据构造决策树。不出现在树中的所有属性假定是不相关的。出现在树中的属性形成归约后的属性子集。 这些方法的结束条件可以不同。该过程可以使用一个度量阈值来决定何时停止属性选择过程。 分类办法决策树 决策树构建，使用属性选择度量来选择将元组最好的划分为不同的类的属性，递归的通过选定的属性，来划分样本（必须是离散值） 树剪枝，决策树建立时，许多分枝反映的是训练数据中的噪声和离群点，树剪枝试图识别并减去这种分枝，以提高对未知数据分类的准确性 提取分类规则，从根到树叶的每条路径创建一个规则，并以“IF-THEN”形式的分类规则表示。示例： IF age=”youth” AND student=”no” THEN buys_computer=”no” 属性选择度量是一种选择分裂准则，将给定类标号的训练元组最好的进行划分的方法，常用的有：① 信息增益；② 增益率；③ Gini 指标。 贝叶斯分类思想：根据某些个先验概率计算Y变量属于某个类别的后验概率比较分类办法使用下列标准比较分类和预测方法 分类器的准确率度量（Accuracy）：模型正确预测新数据的类编号的能力 分类器的灵敏性（Sensitivity）度量和特效性（Specificity）度量 假设已经训练的分类器将医疗数据元组分类为“cancer”和“not_cancer”。90%的准确率使该分类器看上去相当准确，但是，如果只有 3%~4%的训练元组是“cancer”，显然90%的准确率是不可以接受的（比如该分类器只能对“not_cancer”类的元组正确分类，对 “cancer”类的元组全部分类错误）。我们希望有某种度量能够对分类器识别“cancer”元组（设为正元组）和“not_cancer”元组（设为负元组）进行分别评估，为此引入灵敏性（Sensitivity）度量和特效性（Specificity）度量。 速度：产生和使用模型的计算花销 健壮性：给定噪声数据或有空缺值的数据，模型正确预测的能力 可伸缩性：对大量数据，有效的构建分类器或预测器的能力 可解释性：学习模型提供的理解和洞察的层次 过度拟合（Overfit）问题 Overfit是这样一种现象：一个假设在训练数据上能够获得比其他假设更好的拟合，但是在训练数据外的数据集上却不能很好的拟合数据。此时我们就 叫这个假设出现了overfit的现象。 过度拟合产生的原因 噪声数据导致过度拟合由于数据中的噪声和孤立点，许多分枝反应的是训练数据中的异常。 缺乏代表性样本导致过度拟合在训练数据缺乏具有代表的样本的情况下，往往需要继续细化模型才能得到较好拟合训练集的模型，这样得到的模型同样可能具有较高的泛化误差。我们将训练好的模型检验训练集数据，得到的误差率称之为训练误差。将该模型用于检验测试样本，得到的误差率称之为泛化误差。 避免过度拟合的策略与上述两个导致模型过度拟合的因素同时出现的是模型的复杂度。模型越复杂出现过度拟合的概率就越高。因此，对于给定具有相同泛化误差的模型，我们往往更倾向于较为简单的模型，这就是所谓的Occam剃刀（Occam’s Razor）原则。为了避免过度拟合，降低决策树的复杂度，通常的策略是剪枝，该策略采用统计方法删除最不可靠的分支，以提高对未来分类识别的速度和分类 识别新数据的能力。 先剪枝（pre-pruning）法先剪枝法是通过提前停止分支的生长过程，即通过在当前结点上就判断是否需要继续划分该结点所包含训练样本集来实现的。这就需要更为限制性的约束条件，如当观察到衡量不纯性的度量低于某个阈值就停止分支的生长。该方法的优点在于避免产生过分拟合训练数据的过于复杂的子树。但是我们很难为提前终止选择正确的阈值，阈值太高将导致拟合不足，阈值太低则不能充分解决过度拟合问题。 后剪枝（post-pruning）法后剪枝法从一个“充分生长”的树中，按照自底向上的方式修剪多余的分支。对于树中的每个非树叶节点，计算该节点上的子树被剪枝可能出现的期望错误率。使用一个独立的测试集来评估每棵树的准确率，就能得到具有最小期望错误率的决策树。① 用新的叶子节点替换子树，该叶子节点的类标签由子树记录中的多数类确定；② 用子树中最常用的分支代替子树。 J48决策树算法采用了子树提升（Subtree Raising）与子树替换（Subtree Replacement）的修剪策略。计算修剪前后的预期分类错误率，如果修剪导致预期分类错误率变大，则放弃剪枝，保留该结点的相应分支，否则就将相应节点分支修剪删除。在产生一系列经过修剪的决策树候选之后，利用一个独立的测试数据集对这些经过修剪的决策树的分类的准确性进行评价，保留下那些预期分类错误率最小的决策树。与先剪枝相比，后剪枝倾向于产生更好的结果 检验和解释结果在实际问题中，数据往往有许多噪音，所以必须对统计结果进行显著性检验、准确性检验的基础上，对结果进行经验性的解释，已确定结果hi合乎逻辑、合乎情理、合乎直觉的，是能够解决实际问题的，而不是噪音、数据偏差（bias）或过拟合（overfit）的结果。]]></content>
    </entry>

    
  
  
</search>
