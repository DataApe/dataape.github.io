<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python 正则表达式 快速查询]]></title>
      <url>%2F2017%2F05%2F16%2Fpython%2FPython-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%2F</url>
      <content type="text"><![CDATA[正则表达式元字符和语法正则表达式使用 Python 的 raw 字符串表示；在字符串前加个 “r” 反斜杠就不会被任何特殊方式处理。 字符 语法 说明 表达式实例 完整匹配 一般字符 匹配自身 abc abc . 匹配任意除换行符 \n 外的字符 a.c abc \ 转义字符 a.c a.c […] ① 字符逐个列出② 也可以给出范围③ 第一个字符^表示取反 a[bcd]ea[b-d]e[^abc] abeaceade 预定义字符集（写在[…]中） 语法 说明 表达式实例 完整匹配 \d 数字：[0-9] a\dc a2c \D 非数字：[^\d] a\Dc abc \s 空白字符 a\sc a c \S 非空白字符[^\s] a\Sc abc \w 单词字符：[A-Za-z0-9] a\wc abc \W 非单词字符 a\Wc a c 数量词 语法 说明 表达式实例 完整匹配 * 匹配前一个字符&gt;=0次 abc* ababcccc + 匹配前一个字符&gt;=1次 abc+ abcabcccc ? 匹配前一个字符0次或1次 abc? ababc {m} 匹配前一个字符m次 ab{2}c abbc {m,n} 匹配前一个字符m至n次 ab{1,2}c abcabbc 边界匹配 语法 说明 表达式实例 完整匹配 ^ 匹配字符串开头在多行模式中匹配每一行的开头 ^abc abc $ 匹配字符串末尾在多行模式中匹配每一行的末尾 abc$ abc \A 仅匹配字符串开头 \Aabc abc \Z 仅匹配字符串末尾 abc\Z abc \b 匹配任何以’the’开始的字符串 \b the thesame \B 匹配任意包含’the’但不以’the’开头的单词 \B the other 逻辑、分组 语法 说明 表达式实例 完整匹配 l ① l代表左右表达式任意匹配一个② 左边匹配成功则跳过右边③ 如果l没有在（）里面，则它的范围是整个表达式 abcldef abcdef (…) 被括起来的表达式将作为分组 (abc){2}a(123l456)c abcabca456c (?P…) 分组，除了原有的编号外再指定一个别名 (?Pabc){2} abcabc \ 引用编号为的分组匹配到的字符串 (\d)abc\1 1abc15abc5 (?P=name) 引用别名为的分组匹配到的字符串 (?P\d)abc(?P=id) 1abc15abc5 特殊构造（不作为分组） 语法 说明 表达式实例 完整匹配 (?:…) ?? ?? ?? (?iLmsux) iLmsux的每个字符代表一个匹配模式，只能用在正则表达式的的开头，能多选 (?i)abc ABC (?#…) #后的内容将作为注释被忽略 abc(?#comment)123 abc123 (?=…) 之后的字符串内容需要匹配表达式才能匹配成功 a(?=\d) 后面是数字的a (?!…) 之后的字符串内容需要不匹配表达式才能匹配成功 a(?!\d) 后面不是数字的a (?&lt;=…) 之前的字符串内容需要匹配表达式才能匹配成功 (?&lt;=\d)a 前面是数字的a (?&lt;!…) 之前的字符串内容需要不匹配表达式才能匹配成功 (?&lt;!\d)a 前面不是数字的a (?(id/name)ye-patternlno-pattern) 如果编号为id/别名为name的组匹配到字符，则需要匹配yes-pattern，否则需要匹配no-pattern。 ?? ?? 贪婪or非贪婪模式贪婪模式：尽可能大的匹配。非贪婪模式：.?是一个固定的搭配，. 和代表可以匹配任意无限多个字符，加上 ? 表示使用非贪婪模式进行匹配，也就是我们会尽可能短地做匹配，以后我们还会大量用到 .*? 的搭配。 例如：正则表达式”ab“如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab?”，将找到”a”。 re模块Python通过 re模块 提供对正则表达式的支持。使用re的一般步骤是先使用re.compile()函数，将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。 re.compile(pattern[, flags])这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。 第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。 模式 定义 re.I(re.IGNORECASE) 忽略大小写 re.S(DOTALL) 不包括换行符内的所有字符 re.L(LOCALE) 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定 re.M(MULTILINE) 匹配多行字符串 re.X(VERBOSE) 正则表达式为多行 re.U(UNICODE) 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性 re提供了众多模块方法用于完成正则表达式的功能。这些方法可以使用Pattern实例的相应方法替代，唯一的好处是少写一行re.compile()代码，但同时也无法复用编译后的Pattern对象。这些方法将在Pattern类的实例方法部分一起介绍。如上面这个例子可以简写为：12m = re.match(r'hello', 'hello world!')print m.group() Match|re.findall(pattern,string)|搜索字符串，以列表形式返回||re.match()|尝试从字符串的开始匹配一个模式||re.search()|在字符串内查找模式匹配，找到第一个匹配然后返回，如果没有匹配，则返回None||re.sub()|替换||re.split()|切割| 举例re.S的用法（匹配\n，\t换行符）12345import restr="abc\noooass"res="\w&#123;3&#125;.\w&#123;6&#125;"a=re.compile(res,re.S)print a.findall(str) re.M的用法（字符串多行）12345678910import restr="""abc ooabc oooooo abcsia abc"""res='^abc'a=re.compile(res,re.M)print a.findall(str) re.X的用法（正则写多行）123456789import restr="010-12345678"res="""\d&#123;3,4&#125;-?\d&#123;8&#125;"""a=re.compile(res,re.X)print a.findall(str) re.search()12345678#一般用来查询文件中是否有我们想要的字符串，group()输出import restr="Daming is a handsome boy, he is cool"m=re.search(r"(\w+)\s",str)if m:print m.group(0),'\n',m.group(1)else:print 'not match' re.sub()：替换123import rer=r'c..t'print re.sub(r,'python','csvt csst csft') re.split()：切割1234import restr='101+123-123*12233/123'res=r'[-+\*/]'print re.split(res,str)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python 学习集汇总]]></title>
      <url>%2F2017%2F05%2F11%2Fpython%2FPython%20%E5%AD%A6%E4%B9%A0%E9%9B%86%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[安装教程如何安装Python? → http://dataape.github.io/2017/03/09/Python-%E5%AE%89%E8%A3%85/ 语法教程 笨办法学 Python 中文版教程 → http://www.kancloud.cn/wizardforcel/lpthw/92438 这本书绝对是最简单的学习 Python 的方法。你会真实地感受到自己的学习进程，一步步的获取新的知识。 Online Python Tutor：Python 初学者的好帮手 Online Python Tutor 是由 Philip Guo 开发的一个免费教育工具，可帮助学生攻克编程学习中的基础障碍，理解每一行源代码在程序执行时在计算机中的过程。 Learn Python Programming @ Codecademy 在这个 Codecademy 的课程中你将会学到如何用文件，如何使用循环。什么是函数以及他们能用来做什么。这些都是很基础的，但是对初学者很 有好的东西。当需要帮助时有一个交流的论坛，但通常所有东西都能被理解. 目前完成61%，找答案比较费时，转战[Think Python]教程。 简明 Python 教程 非常像 LPTHW，但是在如何制定你的完美学习计划并实施，以及如何开始第一步上 提供了更深的引导，而不会让你丧失自信心。对于那些想学 Python 的人来说它被认为是 最好的初学者教程之一，当然你要先看看前几章，看看自己是否喜欢它的写作风格. Learning with Python How to Think Like a Computer Scientist-Learning with Python Think Python 中文版教程 → http://codingpy.com/books/thinkpython2/ 学习笔记 → Think_Python 读书笔记 Think Python 是一个面向 Python 初学者的一个指南。它从编程的基本概念教起，而且它很仔细地定义了所有的术语，并且很有逻辑性地展现新的概念。像递归和面向对象这样大一点的知识块被分成了一系列更小的步骤，穿插于课程几个章节。 已经完成全部课程，部分习题未做。 网站资源 编程派 - codingpy 玩蛇网 - iplaypy 深度学习 - deeplearning 核心库 Unofficial Windows Binaries for Python Extension Packages // 非官方的Python扩展包(Windows二进制文件)，whl格式 scikit-learn // 建立在NumPy、SciPy matplotlib上，数据挖掘和分析工具，多种回归，分类，聚类，向量机，朴素贝叶斯 mlpy // a high-performance Python library for predictive modeling Statsmodels // 统计建模和计量经济学工具包，包括一些描述统计、统计模型估计和推断。 Scrapy // 爬虫教程 NLTK // 自然语言工具箱（Natural Language Toolkit），是当前最为流行的自然语言编程与开发工具。 Pattern // Python的挖掘模块，拥有以下工具： 数据挖掘：包括网络服务（Google，Twitter，Wikipedia），网络蜘蛛，HTML DOM解析自然语言处理 / 机器学习 / 网络分析 Theano // 深度学习的工具对比 SciPy.org // SciPy是一个开源的Python算法库和数学工具包。包括了以下这些核心包: table th:first-of-type { width: 100px; } 核心包 定义 功能 NumPy Base N-dimensional array package 提供函数、线性代数、傅里叶变换和随机数，整合将C/c++和Fortran代码的工具 SciPy library Fundamental library for scientific computing 构成SciPy堆栈的核心包，提供了许多高效的数值程序：数值积分和最优化 Matplotlib matplotlib 绘图可视化知识点 Matplotlib 教程 绘图库，提供了一整套和matlab相似的命令API，十分适合交互式地进行制图 pandas Data structures &amp; analysis 提供高性能、易于使用的数据结构和数据分析(再加工)工具 Sympy Symbolic mathematics 一个全功能的计算机代数系统(CAS) IPython Enhanced Interactive Console 一个强大的交互式shell，支持交互式数据可视化和GUI工具包的使用 可视化库除了matplotlib，还有 seaborn 等等。 安装库源码安装很多第三方库都是开源的，几乎都可以在github 或者 pypi上找到源码。找到源码格式大概都是 zip\tar.zip\tar.bz2格式的压缩包。解压这些包，进入解压好的文件夹，通常会看见一个 setup.py 的文件。打开命令行，进入该文件夹。运行1python setup.py install 这个命令，就能把这个第三库安装到系统里，也就是你的 Python 路径，windows大概是在 C:\Python2.7\Lib\site-packages。 包管理器（pip 和 easy_install）现在很多编程语言，都带有包管理器，例如 Ruby 的 gem，nodejs的npm。Python当然也不例外，拥有大名鼎鼎的 pip和 easy_install。pypi就是一些 python第三库所在的源，使用 pip 或者 easy_install 安装模块，会搜索这个源，然后自动下载安装。 1. 先安装 pip：下载地址：pip：http://pypi.python.org/pypi/pip#downloads下载pip-8.1.2.tar.gz(md5,pgp)完成之后，解压到一个文件夹，cmd控制台进入解压目录，输入：python setup.py install安装好pip之后，将D:\Python27\Scripts 添加至环境变量。（一般你windows装python2.7的时候，会自动给你安装pip，只需要将D:\Python27\Scripts 添加至环境变量） 2. 安装 wheel:Wheels are the new standard of python distribution and are intended to replace eggs.cmd输入：pip install wheel 3. 库的安装方法 table th:first-of-type { width: 180px; } 方法 命令 安装 flask 框架 pip install flask 或者 easy_install flaskv 卸载flask pip uninstall flask 查看所安装的包 pip list 搜索包 pip search flask 重定向输出项目使用的库 pip freeze &gt; requirements.txt 这样就会把该环境下的第三方库重定向到 requirements.txt文件内 如果给别人安装项目的依赖，只需要运行：pip install -r requirements.txt 有时候网络速度很慢，pip是在线安装的，可不可以离线呢？当然可以啦，pip install 的第一步，就是在 pypi 上寻找包，然后下载到本地。如果网络不好，可以先建一个本地的仓库，把常用的包离线下载。比如可以下载 flask 的源码1pip intall flask-master.zip 但很快就会发现这些源安装超级慢，所以推荐使用 豆瓣的源 加后缀 -i http://...1pip install matplotlib -i http://pypi.douban.com/simple --trusted-host pypi.douban.com 爬虫 Python爬虫：Scrapy框架安装配置 Scrapy入门教程-Scrapy 1.0 中文文档 Python爬虫入门 Python爬虫入门（1）：综述Python爬虫入门（2）：爬虫基础了解Python爬虫入门（3）：Urllib库的基本使用Python爬虫入门（4）：Urllib库的高级用法Python爬虫入门（5）：URLError异常处理Python爬虫入门（6）：Cookie的使用Python爬虫入门（7）：正则表达式Python爬虫入门（8）：Beautiful Soup的用法 Python 正则表达式操作指南 Scrapy 轻松定制网络爬虫 案例 用Scrapy爬虫下载图片(豆瓣电影图片)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据库系统技术的演变]]></title>
      <url>%2F2017%2F05%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E6%BC%94%E5%8F%98%2F</url>
      <content type="text"><![CDATA[数据库管理系统（70-80年代）数据库系统类型 层次数据库 网状数据库 关系数据库 数据建模：实体-联系模型等 索引和存取方法 查询原因：SQL等 用户界面、表单、报表 查询处理与优化 事务、并发控制和恢复 联机事务处理 高级数据库系统（80年代中期-）高级数据模型管理复杂的数据数据流和物联网数据系统基于Web的数据库（XML、语义Web）管理不确定数据和数据清理易构源的集成文本数据库系统以及与信息检索的集成非常大的数据的管理高级查询：排位、skyline等云计算与并行数据处理数据隐私和安全问题高级数据分析（80年代中期-）数据仓库与练级分析处理数据挖掘与知识发现挖掘复杂的数据类型数据挖掘应用数据挖掘与社会]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据挖掘 读书笔记]]></title>
      <url>%2F2017%2F05%2F04%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[第1章 引论为什么进行数据挖掘数据挖掘把大型数据集转换成知识。 案例：http://www.guokr.com/article/438117/Google的Flu Trends(流感趋势)使用特殊的搜索项作为流感活动的指示器，比传统的系统早两周对流感活动作出评估。 什么是数据挖掘数据中的知识发现 数据清理 ：消除噪声和删除不一致的数据 数据集成：多种数据源可以组合在一起 数据选择：从数据库中提取与分析任务相关的数据 数据变换：通过汇总或聚集操作，把数据统一成适合挖掘的形式 数据挖掘：基本步骤，使用智能方法提取数据模式 模式评估：根据魔种兴趣度度量，识别代表知识的真正有趣的模式 知识表示：使用可视化和知识表示技术，向用户提供挖掘的知识 数据库数据数据库管理系统(DBMS)，由一组内部相关的数据（库）和一组管理和存取数据的软件程序组成。关系数据库是表的汇集，每个表都包含一组属性（列或字段），并且存放大量元组（记录或行）。构建语义数据模型，如实体-联系（ER）数据模型。 数据仓库 数据仓库是一种用于长期存储数据的仓库，这些数据来自多个数据源，是经过组织的，以便支持管理决策。数据仓库的核心组件有四个：各源数据库，ETL，数据仓库，前端应用。如下图所示： 数据仓库用称作数据立方体的多维数据结构建模。数据仓库非常适合联机分析处理。OLAP操作包括下钻（drill-down）和上卷（roll-up）。 博文参考：http://www.cnblogs.com/muchen/p/5305658.html 事务数据事务数据库的每个记录代表一个事务，如顾客的一次购物或一个用户的网页点击。通常，一个事务包含一个唯一的事务标识号（trans_ID）。AllElectronics的销售事务数据库sales表的片段： trans_ID 商品ID的列表 T100 I1，I3，I8，I16 T200 I2，I8 … … sales表是一个嵌套关系，因为属性“商品ID的列表”包含商品的集合。作为分析者，你可能问“哪些商品一起销售的很好？”这种“购物篮数据分析”是你能够制定促销策略，将商品捆绑销售。 其他类型的数据 类型 例应用 时间相关或序列数据 历史记录、股票交易数据、时间序列和生物学序列数据 数据流 视频监控和传感器数据，他们连续播送 空间数据 地图 工程设计数据 建筑数据、系统部件或集成电路 超文本和多媒体数据 包括文版、图像、视频和音频数据 图和网状数据 如社会和信息网络 万维网 由Internet提供的巨星、广泛分布的信息存储库 具体应用： 就时间数据而言，可以挖掘银行数据的变化趋势，这可以帮助银行根据顾客流量安排出纳员。 可以挖掘股票交易数据，发现趋势，帮助你规划投资策略（例如，购买AllElectronics的股票的最佳时机）。 可以挖掘计算机网络数据，根据消息流的异常进行入侵检测。这种异常可以通过聚类、流模型的动态创建，或把当前的频繁模式与先前的比较发现。 使用空间数据，我们可以得到根据城市离主要公路的距离描述都市贫困率的变化趋势的模式。 可以考察空间对象集之间的联系，发现那些对象子集是空间自相关或关联的。 通过挖掘文本数据，如挖掘过去10年“数据挖掘”方面的文献，可以了解该领域热点课题的演变。 通过挖掘顾客对产品发表的评论（通常，以短文本信息提交），我们可以评估顾客的意见，了解产品被市场接受的程度。 由多媒体数据，我们可以挖掘图像，识别对象，并通过指派语义标号或标签对它们分类。 通过挖掘曲棍球运动的视频数据，可以检测对应于进球的视频序列。 Web挖掘可以帮助我们了解万维网信息的一般分布，刻画网页的特征，对网页进行分类，并发现Web的动态，以及不同网页、用户、社区和基于Web的活动之间的关联和联系。 可以挖掘什么类型的数据特征化与区分 数据特征化（data characterization）是目标类数据的一般特性或特征的汇总。 例如AllElectronics的客户关系经理可能提出如下数据挖掘任务：“汇总一年之内在AllElectronics花费5000美元以上的顾客特征。”结果可能是顾客的概况，如年龄在40～50岁、有工作、有很好的信用等级。 数据区分（data discrimination）是将目标类数据对象的一般特性与一个或多个对比类对象的一般特性进行比较。 例如频繁购买计算机产品的顾客80%在20～40岁之间，受过大学教育；而不经常购买这种产品的顾客60%或者年龄太大或者太年轻，没有大学学位。 挖掘频繁模式、关联和相关性 频繁模式 频繁项集：如小卖部中被许多顾客频繁地一起购买的牛奶和面包。 频繁子序列：如顾客倾向于先购买便携机，再购买数码相机，然后再购买内存卡这样的模式 频繁子结构：能涉及不同的结构形式（例如，图、树或格），可以与项集或子序列结合在一起。如果一个子结构频繁地出现，则称它为（频繁）结构模式？ 关联分析 buys(X,”computer”) ==&gt; buys(X,”software”)[support=1%,confidence=50%]X是变量，代表顾客。50%的置信度（confidence）表示，如果一位顾客购买计算机，则购买软件的可能性是50%。1%的支持度（support）表示，所分析的所有事务的1%显示计算机与软件一起被购买。这个关联规则涉及单个重复的属性或谓词（即buys）。包含单个谓词的关联规则称作单维关联规则（single-dimensional association rule）。去掉谓词符号，上面的规则可以简单地写成：computer ==&gt; software[1%, 50%] age(X,”20..29”)∧income(X,”40K..49K”) ==&gt; buys(X,”laptop”)[support=2%,confidence=60%]这里涉及多个属性或谓词（即age，income和buys）的关联。采用多维数据库使用的属性，每个属性称作一个维，上面的规则可以称作多维关联规则（multidimensional association rule）。 用于预测分析的分类与回归 分类：找出描述和区分数据类或概念的模型（或函数），分类预测类别（离散的、无序的）标号。 如何提供导出的模型？ 分类规则（即IF-THEN规则）、决策树、神经网络、朴素贝叶斯分类、支持向量机和k最近邻分类。 回归建立连续值函数模型，回归用来预测缺失的或难以获得的数值数据值，而不是（离散的）类标号。 相关分析（relevance analysis）可能需要在分类和回归之前进行，它视图识别与分类和回归过程显著相关的属性。我们将选取这些属性用于分类和回归过程，其他属性是不相关的，可以不必考虑。 聚类分析聚类（clustering）与[分类与回归标记类的（训练）数据集]不同，聚类分析数据对象，而不考虑类标号。对象根据最大化类内相似性、最小化类间相似性的原则进行聚类或分组。 离群点分析数据集中可能包含一些数据对象，他们与数据的一般行为或模型不一致。这些数据对象是离群点（outlier）。大部分数据挖掘方法都将离群点视为噪声或异常而丢弃。然而，在一些应用中（例如，欺诈检测），罕见的事件可能比正常出现的事件更令人感兴趣。离群点数据分析称作离群点检测或异常挖掘。 使用什么技术 统计学 推理统计学用某种方式对数据建模，解释观测中的随机性和确定性，并用来提取关于所考察的过程或总体的结论。统计假设检验使用实验数据进行统计判决。如果结果不大可能随机出现，则称它为统计显著的。 机器学习 考察计算机如何基于数据学习（或提高它们的性能）。其主要研究领域之一是，计算机程序基于数据自动地学习识别复杂的模式，并做出智能的决断。 监督学习（supervised learning）基本是分类的同义词。学习中的监督来自训练数据集中标记的实例。如：邮政编码识别问题。 无监督学习（unsupervised learning）本质上是聚类的同义词。学习过程是没有监督的，因为输入实例没有类标识。 半监督学习（semi-supervised learning）在学习模型中，它使用标识和未标识的实例。在方法中，标识的实例用来学习类模型，而未标识的实例用来进一步改进类边界。 主动学习（active learning）主动学习方法可能要求用户对一个可能来自未标识的实例集或由学习程序合成的实例进行标识。 数据库系统与数据仓库 …… 信息检索 信息检索（IR）是搜索文档或文档中信息的科学。信息检索的典型方法是采用概率模型。一个文本文档集的主题可以用词汇表上的概率分布建模，称作主题模型。 面向什么类型的应用 商务智能 BI技术提供商务运作的历史、现状和预测视图，例子包括报告、联机分析处理（依赖于数据仓库和多维数据挖掘）、商务业绩管理、客户关系管理（聚类）、竞争情报、标杆管理和预测分析。 Web搜索引擎 本质上是大型数据挖掘应用 技术 应用 爬行 决定应该爬过哪些页面和爬行频率 索引 选择被索引的页面和决定构建索引的范围 搜索 确定如何排列各个页面、加载何种广告、如何把搜索结果个性化。当用户提交一个查询时，搜索引擎试图使用用户的简况和他的查询历史推断查询的环境，以便快速地返回更加个性化的回答 数据挖掘的主要问题 挖掘方法 挖掘各种新的知识类型：从数据特征化与区分到关联与相关性分析、分类、回归、聚类、离群点分析、序列分析以及趋势和演变分析。挖掘多维空间中的知识：在不同抽象层的多维（属性）组合中搜索有趣的模式。这种挖掘称作（探索式）数据挖掘。数据挖掘：通过集成来自多学科的新方法可以显著增强数据挖掘的能力。例如，自然语言文本数据挖掘，把数据挖掘方法与信息检索和自然语言处理的方法融合在一起。提升网络环境下的发现能力：大部分数据对象驻留在链接或互连的环境中，多个数据对象之间的语义链接可以用来促进数据的挖掘。处理不确定性、噪声或不完全数据模式评估和模式或约束指导的挖掘：数据挖掘过程产生的所有模式并非都是有趣的。需要一种技术来评估基于主观度量所发现的模式的兴趣度。 用户交互 有效性与伸缩性 数据挖掘算法的有效性和可伸缩性：为了有效地从多个数据库或动态数据流的海量数据中提取信息，数据挖掘算法的运行时间必须是可预计的、短的和可以被应用接受的。并行、分布式和增量挖掘算法：首先把数据划分成若干“片段”，每个片段并行处理，搜索模式。并行处理可以交互，来自每部分的模式最终合并在一起。云计算和集群计算使用分布和协同的计算机处理超大规模计算任务 数据类型的多样性 从结构化数据到半结构化数据和无结构数据从静态的数据到动态的数据流从简单的数据对象到时间数据、生物序列数据、传感器数据、空间数据、超文本数据、多媒体数据、Web数据和社会网络数据。挖掘动态的、网络的、全球的数据库：众多数据源被国际互联网连接起来，形成一个庞大的、分布的和易购的全球信息系统和网络。 数据挖掘与社会 数据挖掘的社会影响保护隐私的数据挖掘：个人信息隐私无形的数据挖掘：在线购买商品时，用户可能并未察觉商店可能正在收集顾客的购买模式数据。 第2章 认识数据数据对象与属性类型 属性、维度、特征和变量可以互换。机器学习文献倾向于使用术语特征，统计学家更愿意使用术语变量，数据库和数据挖掘的专业人士一般使用术语属性。 属性 定义 标称属性（nominal attribute） 值是一些符号或事物的名称，每个值代表某种类别、编码或状态，因此标称又被看做是分类的，并不具有有意义的序。 二元属性（binary attribute） 是一种标称属性，又称布尔属性：0或1 序数属性（ordinary attribute） 其可能的值之间具有有意义的序或秩评定（ranking），中心趋势可以用众数和中位数表示，但不能定义均值 数值属性（numeric attribute） 1.区间标度（interval-scaled）用相等的单位尺度度量2.比率标度属性（retio-scaled）是具有固定零点的数值属性。或比率标度 离散属性与连续属性 离散属性具有有限或无限可数个值 数据的基本统计描述中心趋势度量 均值 均值对极端值很敏感，为了抵消少数极端值的影响，可以使用截尾平均（trimmed mean）。 中位数 对于倾斜（非对称）数据，数据中心的更好度量是中位数（median）。 众数 可能最高频率对应多个不同的众数，1个-单峰的（unimodal），2个-双峰的（bimodal），3个-三峰的（trimodal） 中列数 正倾斜-众数出现在小于中位数的值上；负倾斜-众数出现在大于中位数的值上。 度量数据散布 极差MAX()-MIN() 四分位极差（IQR）=Q3-Q1 离群点：落在第3个四分位数之上或第1个四分位数之下至少1.5 IQR* 五数概括：中位数、四分位数Q1和Q3、最小和最大观测值组成 箱线图（boxplot）：盒子外两条线延伸到最小和最大观测值。（当最高/低值超过1.5 x IQR时，两条线不超过1.5 x IQR） 方差和标准差 数据基本统计的图形 分位数图 分位数-分位数图 直方图 散点图与数据相关 数据可视化1. 基于像素一维值的简单方法是使用像素，其中像素的颜色反映该维的值。 2. 几何投影散点图，使用不同的颜色或形状表示不同的数据点，可以增加第三维。散点图矩阵，对于n维数据集，散点图矩阵是二维散点图的n x n网格。平行坐标（parallel coordinates），绘制n个等距离、相互平行的轴，每维一个。 3. 层次可视化把所有维划分成子集（子空间），这些子空间按层次可视化。① 世界中的世界② 树图 4. 可视化复杂对象和关系-标签云 度量数据的相似性和相异性1. 数据矩阵和相异性矩阵 数据矩阵（data-matrix）或称对象-属性结构：这种数据结构用关系表的形式或n x p(n个对象 x p个属性)矩阵存放n个数据对象。数据矩阵由两种实体组成，即行（代表对象）和列（代表属性）。因而，数据矩阵经常被称为二模（two-mode）矩阵。相异性矩阵（dissimilarity matrix）或称对象-对象结构：存放n个对象两两之间的邻近度（proximity）。相异性矩阵只包含一类实体，因此被称为单模（one-mode）矩阵。 2. 标称属性的近邻性度量根据不匹配率：d(i,j)=(p-m)/pm 是匹配的数目（即i和j取值相同状态的属性数），而p是刻画对象的属性总数。 3. 二元属性的邻近度度量对于对称的二元属性，每个状态都同样重要，基于对称二元属性的相异性称作对称的二元相异性。对于非对称的二元属性，每个状态不是同样重要的，称作非对称的二元相异性。 4. 数值属性的邻近度度量欧几里得距离 L2范数曼哈顿距离 L1范数闵可夫斯基距离（Minkowski distance）又称Lp范数（norm） 5. 序数属性的邻近度度量序数属性的处理与数值属性的非常类似。序数属性的相似值由相异性得到：sim(i,j)=1-d(i,j)巴拉巴拉123#### 6. 混合类型属性的相异性难 7. 余弦相似性文档用以千计的属性表示，每个记录文档中一个特定词或短语的频率。每个文档都被一个所谓的词频向量（term-frequency vector）表示。词频向量通常很长，并且是稀疏的（即，他们有许多是0值）。使用这种结构的应用包括信息检索、文本文档聚类、生物学分类和基因特征映射。 余弦相似性可以用来比较文档，或针对给定的查询词向量对文档排序。sim(x,y)=x*y/(||x|| ||y||) 第3章 数据预处理数据质量的三要素：准确性、完整性和一致性影响数据质量的另外两个因素是可信性和可解释性。 数据清理（data cleaning） 通过填写缺失值，平滑噪声数据，识别或删除离群点，并解决不一致性来“清理”数据。 缺失值 方法 具体做法 1. 忽略元组 ① 当缺少类标号时通常这么做② 除非元组有多个属性缺少值 2. 人工填写缺少值 费时，数据集大，缺失多时，该方法不可用 3. 使用一个全局常量填充 如”Unknown”，方法简单，但并不十分可靠 4. 使用属性的中心度量（均值或中位数） 对称数据分布应该使用均值，倾斜数据分布应该使用中位数 5. 使用与给定元组属同一类的所有样本的属性均值或中位数 如果将顾客按credit_risk分类，则用相同信用风险的顾客的平均首入替换income中的缺失值 6. 使用最有可能的值填充 用回归、贝叶斯形式化方法的基于推理的工具或决策树归纳确定利用数据集中其他顾客的属性，构造一棵决策树，来预测income的缺失值 方法(3)-方法(6)使数据有偏，填入的值可能不正确，方法(6)是最流行的方法。 噪声数据 被测量的变量的随机误差或方差。如何“光滑”数据？ 方法 具体做法 分箱（binning） 1. 划分为（等频的）箱；2. 用箱均值（边界）光滑； 回归（regression） 1. 线性回归：找出拟合两个属性的“最佳”直线，使得一个属性可以用来预测另一个2. 多元线性回归：涉及的属性多于2个，并且数据拟合到一个多维曲面 离群点分析（outlier analysis） 通过如聚类来检测离群点，落在簇集合之外的值被视为离群点 数据清理过程数据清理的第一步是偏差检测：人为数据输入错误、有意的错误（不愿意泄露自己的信息）、数据退化（过时的地址）、不一致的数据表示和编码的不一致。偏差检测和数据变换（纠正偏差）的两步过程迭代执行。这一过程容易出错并且费时。 工具 应用 数据清洗工具（data scrubbing tool） 依赖于分析和模糊匹配技术。 数据审计工具（data auditing tool） 通过分析数据发现规则和联系，并检测违反这些条件的数据来发现偏差。使用统计分析来发现相关性，或通过聚类识别离群点。 数据迁移工具（data migration tool） ETL（Extraction/Transformation/Loading） 工具允许用户通过图形用户界面（GUI）说明变换。 数据集成（data integration）1. 实体识别问题 数据分析任务多半设计数据集成，数据集成将多个数据源中的数据合并，存放在一个一致的数据存储中，如数据仓库。这些数据源可能包括多个数据库、数据立方体或一般文件。 2. 冗余和相关性分析 给定两个属性，相关分析可以根据可用的数据，度量一个属性能多大程度蕴涵另一个。 属性 分析方法 标称数据 X2卡方检验 数值属性 相关系数（correlation coefficient），如果A和B是相关的，并不意味着A导致B或B导致A 数值属性 协方差（covariance） 3. 元组重复除了检测属性间的冗余外，还应当在元组级检测重复。 4. 数据值冲突的检测与处理 同一实体，来自不同数据源的属性值可能不同。这可能是因为表示、尺度或编码不同。重量单位/货币单位/学分制度 数据归约（data reduction） 归约策略-得到数据集的简化表示 方法 维归约（dimensionality reduction）减少所考虑的随机变量或属性的个数 1. 数据压缩技术 （小波变换和主成分分析）2. 属性子集选择 （去掉不相关的属性）3. 属性构造 （从原来的属性集导出更有用的小属性集） 数据归约（numerosity reduction）用替代的、较小的数据表示形式替换原数据 4. 参数模型（回归和对数线性模型）5. 非参数模型（直方图、聚类、抽样或数据聚集） 数据压缩（data compression）使用变换，以便得到原数据的归约或“压缩”表示 6. 无损的：如果原数据能够从压缩后的数据重构7. 有损的：如果只能近似重构原数据 1. 小波变换和主成分分析如果看了此文你还不懂傅里叶变换，那就过来掐死我吧傅立叶分析和小波分析之间的关系主成分分析（PCA）原理详解 2. 属性子集选择 决策树算法（ID3、C4.5和CART）。当决策树归纳用于属性子集选择时，不出现在树中的所有属性假定是不相关的。出现在树中的属性形成归约后的属性子集。这些方法的结束条件可以不同，该过程可以使用一个度量阈值来决定何时停止属性选择过程。 3. 属性构造 在某些情况下，可能基于其他属性创建一些新属性。这种属性构造可以帮助提高准确性和对高维数据结构的理解。 4. 参数模型：回归和对数线性5. 非参数模型 方法 具体实施 直方图 等宽：每个桶的宽度区间是一致的等频（等深）：每个桶的频率粗略的为常数 聚类 用数据的簇代表替换实际数据 抽样 用数据小得多的随机样本（子集）表示大型数据集 数据变换或数据离散化 如果顾客数据包含年龄和年薪属性，年薪属性的取值范围可能比年龄大得多。如果属性未规范化，则距离度量在年薪上所取的权重一般要超过年龄所取的权重。离散化和概念分层，属性的原始值被区间或较高层的概念所取代。 光滑（smoothing） 分箱、回归、聚类 属性（特征）构造 由给定的属性构造新的属性并添加到属性集中 聚集 计算日销售——&gt;月、年销售数据 规范化用较小的单位表示属性将导致该属性具有较大值域，因此趋向于使这样的属性具有较大的影响或较高的权重。为了避免这种情况，数据应该规范化或标准化，使之落入一个小的区间，如0.0~1.0 最小-最大规范化、z-score 规范化、小数定标规范化① 神经网络后向传播算法 规范化有助于加快学习阶段的速度② 基于距离的方法 规范化有助于防止具有较大初始值域的属性（income）与具有较小初始值域的属性（如二元属性）相比权重过大 离散化 分箱基于指定的箱个数的自顶向下的分裂技术，用箱的均值或中位数替代箱中的每个值直方图可以递归地用于每个分区，自动地产生多级概念分层聚类决策树监督的，因为是用了类标号，选择最小化熵的属性的值作为划分点，并递归地划分结果区间，得到分层离散化相关分析ChiMerge是一种基于卡方检验的离散化方法 标称数据产生概念分层 如 street，可以泛化到较高的概念层，如 city 或 country]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PPT资源]]></title>
      <url>%2F2017%2F05%2F04%2FPPT%E8%B5%84%E6%BA%90%2F</url>
      <content type="text"><![CDATA[PPTSTORE 国内高质量原创设计模板，众多国内高手在此聚集，免费模板不多。 逼格PPT 一个关于PPT分享的个人网站，免费分享PPT模板、PPT教程、PPT素材等，质量都非常高。 演界网 PPT模板交易平台，设计师们也会分享免费的PPT模板、PPT教程等，质量都不错 【1】多彩扁平化国外互联网科技公司与产品介绍 【2】公司产品与服务介绍彩色扁平化精美通用商业报告 51PPT模板 免费提供PPT模板、图片、素材、图表、教程等资源。 优品PPT 网站分享高质量的免费PPT模板，包括图表、背景图片、素材、教程等各类PPT资源。 graphicriver 国外最大的PPT模板网站，想要紧跟世界潮流，绝对不能错过这个网站！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Think Python 读书笔记]]></title>
      <url>%2F2017%2F04%2F10%2Fpython%2FThink_Python%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[第一章：程序之道第一个程序1234567# Python3中，print是一个函数；&gt;&gt;&gt; print('Hello, World!')Hello, World!# Python2中，print是一个语句；不是函数，所以不需要使用括号。&gt;&gt;&gt; print 'Hello, World!'Hello, World! 值和类型 值 类型 2 整型数（integer） 42.0 浮点数（floating） ‘Hello,Word!’ 字符串（string） 不确定某个值的类型是什么时，解释器可以告诉你：12&gt;&gt;&gt; type(2)&lt;type 'int'&gt; 第二章：变量、表达式和语句变量名可以包括字母和数字，但是不能以数字开头。下划线_可以出现在变量名中。12&gt;&gt;&gt; class = 'Advanced Theoretical Zymurgy'SyntaxError: invalid syntax class 是Python的关键字之一。 解释器使用关键字识别程序的结构，它们不能被用作变量名。Python3有以下关键词： False None True and as assert break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass raise return try while with yield – – 脚本模式到目前为止，我们都是在交互模式（interactive mode）下运行Python，即直接与解释器进行交互。另一种方法是将代码保存到一个被称为脚本（script）的文件里，然后以脚本模式（script mode）运行解释器并执行脚本（.py）。 字符串运算加号运算符 + 可用于字符串拼接（string concatenation），也就是将字符串首尾相连起来。1234&gt;&gt;&gt; first = 'throat'&gt;&gt;&gt; second = 'warbler'&gt;&gt;&gt; first + secondthroatwarbler 乘法运算符 * 也可应用于字符串；它执行重复运算。 例如，&#39;Spam&#39; * 3 的结果是 ‘SpamSpamSpam’ 。 第三章：函数数学函数Python中有一个数学模块（math），提供了大部分常用的数学函数。模块（module）指的是一个含有相关函数的文件。在使用模块之前，我们需要通过导入语句（import statement）导入该模块：123&gt;&gt;&gt; import math&gt;&gt;&gt; math.sqrt(2) / 2.00.707106781187 组合编程语言的最有用特征之一，是能够将小块构建材料（building blocks）组合（compose）在一起。 例如，函数的实参可以是任意类型的表达式，包括算术运算符：1x = math.sin(degrees / 360.0 * 2 * math.pi) 术语表 名词 定义 形参（parameters） 函数内部用于指向被传作实参的值的名字 实参（argument） 函数调用时传给函数的值。这个值被赋给函数中相对应的形参 局部变量（local variable） 函数内部定义的变量。局部变量只能在函数内部使用 模块（module） 包含了一组相关函数及其他定义的的文件 导入语句（import statement） 读取一个模块文件，并创建一个模块对象的语句 回溯（traceback） 当出现异常时，解释器打印出的出错时正在执行的函数列表 第四章：案例研究：接口设计在cmd下运行Python脚本方法1 新建个.py文件，写上Python代码，每个.py文件都是可以认为是一个Python模块 打开Windows的cmd，并且切换（cd）到对应的python脚本所在目录 输入你的Python脚本，即.py文件的完整的文件名 可以利用Tab键，然后会自动显示出当前目录的文件，多次按Tab键，会在多个文件之间切换。 然后输入回车，即可运行对应的Python脚本 方法2 Python D\:Python27\mypy\文件名.py 如何使用Python的交互式的shell（command line模式和GUI模式）Python有个shell，提供一个Python运行环境。即写一行代码，就可以立刻被运行，然后方便查看到结果。而Python的Shell，在Windows环境下，又分两种：Python (command line) 和IDLE (Python GUI)，两者都比较适合偶尔要测试少量的Python代码的情况下去使用，而不适合长期的开发Python。 如果要调用另一个python脚本用 import 文件名（不包括.py)，这个脚本要在PYTHONPATH的路径下。 在python里建一个文件夹，专门存放你的模块，例如：在python.exe路径下建了一个名为mypy的文件夹 设置一个环境变量PYTHONPATH，以便Python解释器找到相应模块 步骤：计算机&gt;&gt;属性&gt;&gt;高级系统设置&gt;&gt;环境变量&gt;&gt;系统变量&gt;&gt;新建&gt;&gt;变量名：PYTHONPATH; 变量值：D\:Python27\mypy 执行以下代码，mypy也会同其他系统path一起显示出来！12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path ​ 什么是Python的IDE开发Python过程中，写Python代码，调试Python代码，查找相关的函数的解释等等操作，如果都是基于前面介绍的，用Notepad++等编辑器去编辑Python代码，写完代码了，再切换到windows的cmd中去运行，往往觉得很麻烦。尤其是大型项目的话，可能就更加显得不那么高效；以及对应的需要一些额外的功能，比如调试复杂的Python代码，需要一点点跟踪调试，找到错误的根本原因等等。 Python发展到现在，已经有了很多第三方的，别人开发的，可以用于或者专门用于Python开发的一些集成开发环境，即Python的IDE。 术语表： 名词 定义 封装（encapsulation） 将一个语句序列转换成函数定义的过程 泛化（generalization） 使用某种可以算是比较通用的东西（像变量和形参），替代某些没必要那么具体的东西（像一个数字）的过程 关键字实参（keyword argument） 包括了形参名称作为“关键字”的实参 接口（interface） 对如何使用一个函数的描述，包括函数名、参数说明和返回值 重构（refactoring） 修改一个正常运行的函数，改善函数接口及其他方面代码质量的过程 第五章：条件和递归递归一个调用它自己的函数是递归的（recursive）； 这个过程被称作递归（recursion），例如：12345678&gt;&gt;&gt; def countdown(n): if n &lt;= 0: print('Blastoff!') else: print(n) countdown(n-1)&gt;&gt;&gt; countdown(3) 堆栈图 在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。 每当一个函数被调用时，Python生成一个新的栈帧，用于保存函数的局部变量和形参。通常，堆栈的顶部是__main__栈帧。 因为我们在__main__中没有创建任何变量，也没有传递任何实参给它， 所以它是空的。 对于形参n，四个 countdown 栈帧有不同的值。 n=0的栈底，被称作基础情形（base case）。 它不再进行递归调用了，所以没有更多的栈帧了。 举个栗子：阶乘 n!=n(n−1)!1234567&gt;&gt;&gt; def factorial(n): if n == 0: return 1 else: recurse = factorial(n-1) result = n * recurse return result 堆栈图该图中的返回值被描绘为不断被传回到栈顶。 在每个栈帧中，返回值就是结果值，即是 n 和 recurse 的乘积。 再举个栗子：斐波那契数列除了阶乘以外，使用递归定义的最常见数学函数是 fibonaccifibonacci(0) = 0fibonacci(1) = 1fibonacci(n) = fibonacci(n−1) + fibonacci(n−2)1234567def fibonacci (n): if n == 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2) 如果我们将 1.5 作为参数调用阶乘函数会怎样？看上去像是一个无限循环。函数的基础情形是 n == 0 。 但是如果 n 不是一个整型数呢，我们会错过基础情形，永远递归下去。在第一次递归调用中，n 的值是 0.5 。下一次，是 -0.5 。自此它会越来越小，但永远不会是 0 。 我们可以使用内建函数 isinstance 来验证实参的类型。确保该实参是正数：1234567891011def factorial (n): if not isinstance(n, int): print('Factorial is only defined for integers.') return None elif n &lt; 0: print('Factorial is not defined for negative integers.') return None elif n == 0: return 1 else: return n * factorial(n-1) 此程序演示了一个有时被称作 监护人（guardian） 的模式。 前两个条件扮演监护人的角色，避免接下来的代码使用引发错误的值。 术语表 名词 定义 临时变量（temporary variable） 一个在复杂计算中用于存储过度值的变量 死代码（dead code） 程序中永远无法执行的那部分代码，通常是因为其出现在一个返回语句之后 增量式开发（incremental development） 一种程序开发计划，目的是通过一次增加及测试少量代码的方式，来避免长时间的调试 脚手架代码（scaffolding） 程序开发中使用的代码，但并不是最终版本的一部分 监护人（guardian） 一种编程模式，使用条件语句来检查并处理可能引发错误的情形 第七章：迭代迭代，即重复运行某个代码块的能力。 之前已经接触了一种利用递归进行迭代的方式； 在简单的重复一节中，接触了另一种利用 for 循环进行迭代的方式。 在本章中，我们将讨论另外一种利用 while 语句实现迭代的方式。12345def countdown(n): while n &gt; 0: print(n) n = n - 1 print('Blastoff!') while 语句 首先判断条件为真还是为假。 如果为假，退出 while 语句，然后执行接下来的语句； 如果条件为真，则运行 while 语句体，运行完再返回第一步； 这种形式的流程叫做循环（loop），因为第三步后又循环回到了第一步。 break有些时候循环执行到一半你才知道循环该结束了。这种情况下，你可以使用break语句来跳出循环。 调试更多的代码意味着更高的出错概率，并且会有更多隐藏 bug 的地方。减少调试时间的一个方法就是 对分调试 。例如，如果程序有100行，你一次检查一行，就需要100步。 术语表 名词 定义 初始化（initialize） 给后面将要更新的变量一个初始值的一种赋值方法 递增（increment） 通过增加变量的值的方式更新变量（通常是加 1） 递减（decrement） 通过减少变量的值的方式来更新变量 迭代（iteration） 利用递归或者循环的方式来重复执行代一组语句的过程 第八章：字符串字符串是一个序列(sequence)1234&gt;&gt;&gt; fruit = 'banana'&gt;&gt;&gt; letter = fruit[1]&gt;&gt;&gt; letter'a' 对于大多数人，’banana’ 的第一个字母是 b 而不是 a 。 但是对于计算机科学家，索引是从字符串起点开始的位移量 F(offset) ，第一个字母的位移量就是 0 。 字符串切片字符串的一个片段被称作 切片(slice) 。 选择一个切片的操作类似于选择一个字符：12345&gt;&gt;&gt; s = 'Monty Python'&gt;&gt;&gt; s[0:5]'Monty'&gt;&gt;&gt; s[6:12]'Python' [n:m] 操作符返回从第n个字符到第m个字符的字符串片段，包括第一个，但是不包括最后一个 字符串是不可变的123&gt;&gt;&gt; greeting = 'Hello， world!'&gt;&gt;&gt; greeting[0] = 'J'TypeError: 'str' object does not support item assignment 出现此错误的原因是字符串是 不可变的(immutable) ，这意味着你不能改变一个已存在的字符串。 搜索遍历一个序列并在找到寻找的东西时返回 —— 被称作 搜索(search) 。1234567def find(word， letter): index = 0 while index &lt; len(word): if word[index] == letter: return index index = index + 1 return -1 循环和计数下面的程序计算字母a在字符串中出现的次数：123456word = 'banana'count = 0for letter in word: if letter == 'a': count = count + 1print count 字符串方法字符串提供了可执行多种有用操作的 方法(method) 。方法和函数类似，接受实参并返回一个值，但是语法不同。 例如：upper，不过使用的不是函数语法 upper(word) ， 而是方法的语法 word.upper() 。1234&gt;&gt;&gt; word = 'banana'&gt;&gt;&gt; new_word = word.upper()&gt;&gt;&gt; new_word'BANANA' 点标记法的形式指出方法的名字: upper，以及应用该方法的字符串的名字: word 。空括号表明该方法 不接受实参。这被称作方法调用(invocation) ；在此例中，我们可以说是在 word 上调用 upper 。事实上，有一个被称为 find 的字符串方法， 与我们之前写的函数极其相似：1234&gt;&gt;&gt; word = 'banana'&gt;&gt;&gt; index = word.find('a')&gt;&gt;&gt; index1 in 运算符单词 in 是一个布尔运算符1234def in_both(word1， word2): for letter in word1: if letter in word2: print(letter) 术语表|对象（object）|变量可以引用的东西。现在你将对象和值等价使用||序列（sequence）|一个有序的值的集合，每个值通过一个整数索引标识||元素（item）|序列中的一个值||索引（index）|用来选择序列中元素（如字符串中的字符）的一个整数值。 在Python中，索引从0开始||切片（slice）|以索引范围指定的字符串片段||空字符串（empty string）|一个没有字符的字符串，长度为0，用两个引号表示||不可变 （immutable）|元素不能被改变的序列的性质||遍历（traversal）|对一个序列的所有元素进行迭代，对每一元素执行类似操作||搜索（search）|一种遍历模式，当找到搜索目标时就停止||方法调用(invocation)|执行一个方法的声明| 第十章：列表列表是一个序列在字符串中，每个值都是字符； 在列表中，值可以是任何数据类型。列表中的值称为 元素（element） ，有时也被称为 项（item） 。一个列表在另一个列表中，称为嵌套（nested）列表。1['spam', 2.0, 5, [10, 20]] 列表是可变的和字符串不同的是，列表是可变的。当括号运算符出现在赋值语句的左边时，它就指向了列表中将被赋值的元素。1234&gt;&gt;&gt; numbers = [42, 123]&gt;&gt;&gt; numbers[1] = 5&gt;&gt;&gt; numbers[42, 5] 列表操作123456789101112# 运算符 + 拼接多个列表：&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = [4, 5, 6]&gt;&gt;&gt; c = a + b&gt;&gt;&gt; c[1, 2, 3, 4, 5, 6]# 运算符 * 以给定次数的重复一个列表:&gt;&gt;&gt; [0] * 4[0, 0, 0, 0]&gt;&gt;&gt; [1, 2, 3] * 3[1, 2, 3, 1, 2, 3, 1, 2, 3] 第一个例子重复4次。第二个例子重复了那个列表3次。 列表切片切片（slice） 运算符同样适用于对列表：123&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']&gt;&gt;&gt; t[1:3]['b', 'c'] 如果你省略第一个索引，切片将从列表头开始。如果你省略第二个索引，切片将会到列表尾结束。切片运算符放在赋值语句的左边时，可以一次更新多个元素：12&gt;&gt;&gt; t = ['a', 'b', 'c', 'd', 'e', 'f']&gt;&gt;&gt; t[1:3] = ['x', 'y'] 列表方法append 添加一个新元素到列表的末端:1234&gt;&gt;&gt; t = ['a', 'b', 'c']&gt;&gt;&gt; t.append('d')&gt;&gt;&gt; t['a', 'b', 'c', 'd'] extend 将接受一个列表作为参数，并将其其中的所有元素添加至目标列表中：12345&gt;&gt;&gt; t1 = ['a', 'b', 'c']&gt;&gt;&gt; t2 = ['d', 'e']&gt;&gt;&gt; t1.extend(t2)&gt;&gt;&gt; t1['a', 'b', 'c', 'd', 'e'] sort 将列表中的元素从小到大进行排序：1234&gt;&gt;&gt; t = ['d', 'c', 'e', 'b', 'a']&gt;&gt;&gt; t.sort()&gt;&gt;&gt; t['a', 'b', 'c', 'd', 'e'] 映射、筛选和归并删除元素如果你知道元素的下标，你可以使用 pop ：123456&gt;&gt;&gt; t = ['a', 'b', 'c']&gt;&gt;&gt; x = t.pop(1)&gt;&gt;&gt; t['a', 'c']&gt;&gt;&gt; x'b' 如果你知道要删除的值（但是不知道其下标），你可以使用 remove ：1234&gt;&gt;&gt; t = ['a', 'b', 'c']&gt;&gt;&gt; t.remove('b')&gt;&gt;&gt; t['a', 'c'] 列表和字符串一个字符串是多个字符组成的序列，一个列表是多个值组成的序列。但是一个由字符组成的列表不同于字符串。 Method Code list字符串转换为字符的列表 &gt;&gt;&gt; s = &#39;spam&#39; &gt;&gt;&gt; t = list(s) &gt;&gt;&gt; t [&#39;s&#39;, &#39;p&#39;, &#39;a&#39;, &#39;m&#39;] split一个字符串分割成一些单词 &gt;&gt;&gt; s = &#39;pining for the fjords&#39;&gt;&gt;&gt; t = s.split()&gt;&gt;&gt; t[&#39;pining&#39;, &#39;for&#39;, &#39;the&#39;, &#39;fjords&#39;] delimiter指定什么字符作为单词之间的分界线 &gt;&gt;&gt; s = &#39;spam-spam-spam&#39;&gt;&gt;&gt; delimiter = &#39;-&#39;&gt;&gt;&gt; t = s.split(delimiter)&gt;&gt;&gt; t[&#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;] join 一个字符串方法，需要在一个分隔符上调用它，并传入一个列表作为参数 &gt;&gt;&gt; t = [&#39;pining&#39;, &#39;for&#39;, &#39;the&#39;, &#39;fjords&#39;]&gt;&gt;&gt; delimiter = &#39; &#39;&gt;&gt;&gt; s = delimiter.join(t)&gt;&gt;&gt; s&#39;pining for the fjords&#39; 术语表 列表（list） 多个值组成的序列 元素（element） 列表（或序列）中的一个值，也称为项 嵌套列表（nested list） 作为另一个列表的元素的列表 累加器（accumulator） 循环中用于相加或累积出一个结果的变量 增量赋值语句（augmented assignment） 一个使用类似 += 操作符来更新一个变量的值的语句 归并（reduce） 遍历序列，将所有元素求和为一个值的处理模式 映射（map） 遍历序列，对每个元素执行操作的处理模式 筛选（filter） 遍历序列，选出满足一定标准的元素的处理模式 对象（object） 变量可以指向的东西。一个对象有数据类型和值 相等（equivalent） 有相同的值 相同（identical） 是同一个对象（隐含着相等） 引用（reference） 一个变量和它的值之间的关联 别名使用 两个或者两个以上变量指向同一个对象的情况 分隔符（delimiter） 一个用于指示字符串分割位置的字符或者字符串 第十一章：字典字典即映射字典包含了一个索引的集合，被称为键（keys） ，和一个值(values)的集合。 一个键对应一个值。这种一一对应的关联被称为 键值对（key-value pair)， 有时也被称为 项（item）。 字典作为计数器集合生成一个字典，将字符作为键，计数器作为相应的值。字母第一次出现时，你应该向字典中增加一项。 这之后，你应该递增一个已有项的值。12345678910111213141516def histogram(s): d = dict() # 生成一个空字典 for c in s: if c not in d: d[c] = 1 else: d[c] += 1 return d&gt;&gt;&gt; h = histogram('brontosaurus')&gt;&gt;&gt; h&#123;'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1&#125;# 重申一遍，字典中的键是无序的。 如果要以确定的顺序遍历字典，你可以使用内建方法 sorted&gt;&gt;&gt; for key in sorted(h): print key, h[key] 字典和列表在字典中，列表可以作为值出现。但是不能是键，字典使用哈希表实现，这意味着键必须是 可哈希的（hashable）。倒转字典的函数：12345678910111213141516def invert_dict(d): inverse = dict() for key in d: val = d[key] if val not in inverse: inverse[val] = [key] else: inverse[val].append(key) return inverse&gt;&gt;&gt; hist = histogram('parrot')&gt;&gt;&gt; hist&#123;'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1&#125;&gt;&gt;&gt; inverse = invert_dict(hist)&gt;&gt;&gt; inverse&#123;1: ['a', 'p', 't', 'o'], 2: ['r']&#125; 备忘录fibonacci 函数，输入的实参越大，函数运行就需要越多时间。 而且运行时间增长得非常快。要理解其原因，请看 fibonacci 的 调用图（call graph） ： 保存已经计算过的值，将它们存在一个字典中。存储之前计算过的值以便今后使用，它被称作 备忘录（memo） 。当 fibonacci 被调用时，它先检查 known 。 如果结果存在，则立即返回。 否则，它必须计算新的值，将其加入字典，并返回它。123456789known = &#123;0:0, 1:1&#125;def fibonacci(n): if n in known: return known[n] res = fibonacci(n-1) + fibonacci(n-2) known[n] = res return res 全局变量术语表 名词 定义 字典（dictionary） 将键映射到对应值的映射 键值对（key-value pair）/项（item） 键值之间映射关系的呈现形式 实现（implementation） 执行计算的一种形式 哈希表（hashtable） 用来实现Python字典的算法 哈希函数（hash function） 哈希表用来计算键的位置的函数 可哈希的（hashable） 具备哈希函数的类型。诸如整数、浮点数和字符串这样的不可变类型是可哈希的；诸如列表和字典这样的可变对象是不可哈希的 逆向查找（reverse lookup） 接受一个值并返回一个或多个映射至该值的键的字典操作 raise语句 专门印发异常的一个语句 调用图（call graph） 绘出程序执行过程中创建的每个栈帧的调用图，其中的箭头从调用者指向被调用者 备忘录（memo） 一个存储的计算值，避免之后进行不必要的计算 标记（flag） 用于说明一个条件是否为真的布尔变量 声明（declaration） 类似global这种告知解释器如何处理变量的语句 第十二章：元组元组是不可变的元组是一组值的序列，其中的值可以是任意类型。元组与列表非常相似。 二者不同之处在于元组的不可变性。1234567891011121314151617# 元组是用逗号隔开一系列值，通常用括号括起来&gt;&gt;&gt; t = ('a', 'b', 'c', 'd', 'e')# 使用单一元素创建元组时，需要在结尾处添加一个逗号&gt;&gt;&gt; t1 = 'a',&gt;&gt;&gt; type(t1)&lt;class 'tuple'&gt;# 将值放置在括号中并不会创建元组&gt;&gt;&gt; t2 = ('a')&gt;&gt;&gt; type(t2)&lt;class 'str'&gt;# 如果实参是一个序列（字符串、列表或者元组），结果将是一个包含序列内元素的元组。&gt;&gt;&gt; t = tuple('lupins')&gt;&gt;&gt; t('l', 'u', 'p', 'i', 'n', 's') 关系型运算符也适用于元组和其他序列：12&gt;&gt;&gt; (0, 1, 2000000) &lt; (0, 3, 4)True 元组赋值12345678910# 两个变量互换值&gt;&gt;&gt; a, b = b, a# 将一个电子邮箱地址分成用户名和域名&gt;&gt;&gt; addr = 'monty@python.org'&gt;&gt;&gt; uname, domain = addr.split('@')&gt;&gt;&gt;&gt; uname'monty'&gt;&gt;&gt; domain'python.org' 元组作为返回值内建函数 divmod 接受两个实参，返回包含两个值的元组：商和余数123456&gt;&gt;&gt; t = divmod(7, 3)&gt;&gt;&gt; t(2, 1)&gt;&gt;&gt;def min_max(t):return min(t), max(t) 可变长度参数元组函数可以接受可变数量的参数。 以 * 开头的形参将输入的参数汇集到一个元组中。1234&gt;&gt;&gt; def printall(*args): print(args)&gt;&gt;&gt; printall(1, 2.0, '3')(1, 2.0, '3') 与汇集相对的，是分散（scatter）。如果你有一个值序列，想将其作为多个参数传递给一个函数，你可以使用运算符 *。1234567&gt;&gt;&gt; t = (7, 3)&gt;&gt;&gt; divmod(t)TypeError: divmod expected 2 arguments, got 1# 但是如果你将这个元组分散，它就可以被传递进函数：&gt;&gt;&gt; divmod(*t)(2, 1) 列表和元组zip 是一个内建函数，可以接受将两个或多个序列组，并返回一个元组列表，其中每个元组包含了各个序列中相对位置的一个元素。这个函数的名称来自名词拉链(zipper)，后者将两片链齿连接拼合在一起。12345678910111213141516171819202122&gt;&gt;&gt; s = 'abc'&gt;&gt;&gt; t = [0, 1, 2]&gt;&gt;&gt; zip(s, t)&lt;zip object at 0x7f7d0a9e7c48&gt;# 输出的结果是一个 zip 对象&gt;&gt;&gt; for pair in zip(s, t): print(pair)('a', 0)('b', 1)('c', 2)# 通过 zip 对象创建一个列表&gt;&gt;&gt; t=list(zip(s, t))&gt;&gt;&gt; t[('a', 0), ('b', 1), ('c', 2)]&gt;&gt;&gt; for letter, number in t: print(number, letter)0 a1 b2 c 如果需要遍历一个序列的元素以及其索引号，您可以使用内建函数 enumerate ：12for index, element in enumerate('abc'): print(index, element) 术语表 名词 定义 元组（tuple） 一个由多个元素组成的不可变序列 元组赋值（tuple assignment） 一种赋值方式，等号右侧为一个序列，等号左侧为一个变量组成的元组。右侧的表达式先求值，然后其元素被赋值给左侧元组中对应的变量 汇集（gather） 组装可变长度实参元组的一种操作 分散（scatter） 将一个序列变换成一个参数列表的操作 zip 对象 使用内建函数 zip 所返回的结果；它是一个可以对元组序列进行迭代的对象 迭代器（iterator） 一个可以对序列进行迭代的对象，但是并不提供列表操作符和方法 数据结构（data structure） 一个由关联值组成的的数据集合，通常组织成列表、字典、元组等 形状错误（shape error） 由于某个值的形状出错，而导致的错误；即拥有错误的类型或大小 第十三章：案例研究：数据结构选择词频分析随机数伪随机数不是真正的随机数，因为它们由一个确定性的计算生成 randdom模块 参数解释 randomx = random.random() 返回一个 0.0 到 1.0 之间的随机浮点数（包括 0.0 ，但是不包括 1.0 ） randintrandom.randint(5, 10) 接受参数 low 和 high ， 返回一个 low 和 high 之间的整数（两个都包括） choicerandom.choice(t) 从一个序列t中随机选择一个元素 待续 第十四章：文件读取和写入要写入一个文件，你必须在打开文件时设置第二个参数来为 w 模式：1234&gt;&gt;&gt; fout = open('output.txt', 'w')&gt;&gt;&gt; line1 = "This here's the wattle,\n"&gt;&gt;&gt; fout.write(line1)&gt;&gt;&gt; fout.close() 如果该文件已经存在，那么用写入模式打开它将会清空原来的数据并从新开始。完成文件写入后，你应该关闭文件。如果你不关闭这个文件，程序结束时它才会关闭。 格式化运算符write的参数必须是字符串，所以如果想要在文件中写入其它值，我们需要先将它们转换为字符串。使用 格式化运算符（format operator） ，即 % 。作用于整数时，% 是取模运算符，而当第一个运算数是字符串时，% 则是格式化运算符。12&gt;&gt;&gt; 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')'In 3 years I have spotted 0.1 camels.' 文件名和路径 os模块(operating system) 提供了操作文件和目录的函数 os.getcwd 返回当前目录的名称current working directory os.path.abspath 绝对路径（absolute path） os.path.exists 检查一个文件或者目录是否存在 os.path.isdir 检查它是否是一个目录 os.path.isfile 检查它是否是一个文件 os.listdir 返回给定目录下的文件列表 遍历一个目录，打印所有文件的名字，并且针对其中所有的目录递归的调用自身：1234567def walk(dirname): for name in os.listdir(dirname): path = os.path.join(dirname, name) if os.path.isfile(path): print(path) else: walk(path) 数据库举个例子，我接下来创建建一个包含图片文件标题的数据库。 dbm模块 提供了一个创建和更新数据库文件的接口 db = dbm.open(‘captions’, ‘c’) 模式 ‘c’ 代表如果数据库不存在则创建该数据库 db[‘cleese.png’] = ‘Photo of John Cleese.’ 创建一个新项时，dbm 将更新数据库文件 db[‘cleese.png’] 访问某个项时，dbm 将读取文件 b’Photo of John Cleese.’ db.close() 操作后需要关闭文件 一些字典方法，例如 keys 和 items ，不适用于数据库对象，但是 for 循环依然适用：12for key in db: print(key, db[key]) 序列化dbm 的一个限制在于键和值必须是字符串或者字节。pickle模块 能将几乎所有类型的对象转化为适合在数据库中存储的字符串，以及将那些字符串还原为原来的对象。123456789101112# pickle.dumps读取一个对象作为参数，并返回一个字符串表示：&gt;&gt;&gt; import pickle&gt;&gt;&gt; t = [1, 2, 3]&gt;&gt;&gt; pickle.dumps(t)b'\x80\x03]q\x00(K\x01K\x02K\x03e.'# pickle.loads （“load string”）可以重建对象：&gt;&gt;&gt; t1 = [1, 2, 3]&gt;&gt;&gt; s = pickle.dumps(t1)&gt;&gt;&gt; t2 = pickle.loads(s)&gt;&gt;&gt; t2[1, 2, 3] 你可以使用 pickle 将非字符串对象存储在数据库中。 事实上，这个组合非常常用，已经被封装进了模块 shelve 中。 管道???编写模块任何包含 Python 代码的文件，都可以作为模块被导入。作为模块的程序通常写成以下结构：12if __name__ == '__main__': print(linecount('wc.py')) _name_是一个在程序开始时设置好的内建变量。 如果程序以脚本的形式运行，__name__ 的值为 __main__ ，这时其中的代码将被执行。否则当被作为模块导入时，其中的代码将被跳过。 调试当你读写文件时，可能会遇到空白带来的问题。内建函数 repr 可以用来解决这个问题。它返回一个该对象的字符串表示。对于空白符号，它将用反斜杠序列表示：123456&gt;&gt;&gt; s = '1 2\t 3\n 4'&gt;&gt;&gt; print(s)1 2 3 4&gt;&gt;&gt; print(repr(s))'1 2\t 3\n 4' 术语表 名词 定义 格式化运算符（format operator） % 读取一个格式化字符串和一个元组，生成一个包含元组中元素的字符串，按照格式化字符串的要求格式化 格式化字符串（format string） 一个包含格式化序列的字符串，和格式化运算符一起使用 格式化序列（format sequence） 格式化字符串中的一个字符序列，例如%d，指定了一个值的格式 捕获（catch） 为了防止程序因为异常而终止，使用 try 和 except 语句来捕捉异常 管道对象（pipe object） 一个代表某个正在运行的程序的对象，允许一个 Python 程序去运行命令并得到运行结果 第十五章：类和对象程序员自定义类型我们已经使用过了许多 Python 的内置类型； 现在我们要定义一个新类型。举个例子，我们来创建一个叫做 Point 的类型，代表二维空间中的一个点(x,y)。在 Python 中，有几种表示点的方法： 我们可以将坐标存储在两个独立的变量，x和y中。 我们可以将坐标作为一个列表或者元组的元素存储。 我们可以创建一个新类型将点表示为对象。 程序员自定义类型( A programmer-defined type )也被称作类（class）。 定义一个叫做 Point 的类将创建了一个类对象（class object）:123456789&gt;&gt;&gt; class Point: &quot;&quot;&quot;Represents a point in 2-D space.&quot;&quot;&quot; # 主体部分是文档字符串，用来解释这个类的用途。&gt;&gt;&gt; Point&lt;class &apos;__main__.Point&apos;&gt; # 由于 Point 是定义在顶层的，所以它的“全名”是__main__.Point。&gt;&gt;&gt; blank = Point()&gt;&gt;&gt; blank&lt;__main__.Point object at 0xb7e9d3ac&gt; 类对象就像是一个用来创建对象的工厂。创建一个新对象的过程叫做实例化（instantiation），这个新对象叫做这个类的一个实例（instance）。 属性你可以使用点标记法向一个实例进行赋值操作：12&gt;&gt;&gt; blank.x = 3.0&gt;&gt;&gt; blank.y = 4.0 变量 blank 引用了一个 Point 类，这个类拥有了两个属性。 每个属性都引用了一个浮点数。 矩形为了描述一个矩形的位置和大小，你需要设计哪些属性呢？ 至少有两种可能的设计： 你可以指定矩形的一个角（或是中心）、宽度以及长度。 你可以指定对角线上的两个角。 这个时候还不能够说明哪个方法优于哪个方法。我们先来实现前者。下面是类的定义：12345class Rectangle: &quot;&quot;&quot;Represents a rectangle. attributes: width, height, corner. &quot;&quot;&quot; 文档字符串中列出了属性：width 和 height 是数字； corner是一个 Point 对象，代表左下角的那个点。为了描述一个矩形，你需要实例化一个 Rectangle 对象，并且为它的属性赋值：表达式 box.corner.x 指， 前往 box 所引用的对象，找到叫做 corner 的属性； 然后前往 corner 所引用的对象，找到叫做 x 的属性。123456box = Rectangle()box.width = 100.0box.height = 200.0box.corner = Point()box.corner.x = 0.0box.corner.y = 0.0 对象图展示了这个对象的状态。 一个对象作为另一个对象的属性叫做嵌套（embedded）。 术语表 名词 定义 类（class） 一种程序员自定义的类型。类定义创建了一个新的类对象 类对象（class object） 包含程序员自定义类型的细节信息的对象。类对象可以被用于创建该类型的实例 实例（instance） 属于某个类的对象 实例化（instantiate） 创建新的对象 属性（attribute） 和某个对象相关联的有命名的值 嵌套对象（embedded object） 作为另一个对象的属性存储的对象 浅复制（shallow copy） 在复制对象内容的时候，只包含嵌套对象的引用，通过 copy 模块的copy函数实现 深复制（deep copy） 在复制对象内容的时候，既复制对象属性，也复制所有嵌套对象及其中的所有嵌套对象，由 copy 模块的deepcopy函数实现 对象图（object diagram） 展示对象及其属性和属性值的图 第十六章：类和函数术语表 名词 定义 原型和补丁（prototype and patch） 一种开发方案，编写一个程序的初稿，测试，发现错误时修正它们 设计开发（designed development） 一种开发方案，需要对问题有更高层次的理解，比增量开发或原型开发更有计划性 纯函数（pure function） 一种不修改任何作为参数传入的对象的函数。大部分纯函数是有返回值的（fruitful） 修改器（modifier） 一种修改一个或多个作为参数传入的对象的函数。大部分修改器没有返回值；即返回 None 函数式编程风格（functional programming style） 一种程序设计风格，大部分函数为纯函数 不变式（invariant） 在程序执行过程中总是为真的条件 断言语句（assert statement） 一种检查条件是否满足并在失败的情况下抛出异常的语句 第十七章：类和方法 第十九章：进阶小技巧条件表达式1234567if x &gt; 0: y = math.log(x)else: y = float('nan')# 我们可以使用 条件表达式 简化这个语句：y = math.log(x) if x &gt; 0 else float('nan') 列表推导式123456789def capitalize_all(t): res = [] for s in t: res.append(s.capitalize()) return res# 我们可以使用 列表推导式 简化该函数：def capitalize_all(t): return [s.capitalize() for s in t] 生成器表达式生成器表达式与列表推导式类似，但是使用的是圆括号，而不是方括号：123&gt;&gt;&gt; g = (x**2 for x in range(5))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x7f4c45a786c0&gt; any 和 all12&gt;&gt;&gt; any(letter == 't' for letter in 'monty')True Python还提供了另一个内建函数 all，如果序列中的每个元素均为 True 才会返回 True 。 集合返回不在 d2 中但在 d1 里的键组成的字典。12345678910def subtract(d1, d2): res = dict() for key in d1: if key not in d2: res[key] = None return res# Python提供了另一个叫做集合的内建类型，它的行为类似没有值的字典键集合。def subtract(d1, d2): return set(d1) - set(d2) 计数器计数器（Counter）类似集合，区别在于如果某个元素出现次数超过一次，计数器就会记录其出现次数。1234&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; count = Counter('parrot')&gt;&gt;&gt; countCounter(&#123;'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1&#125;) 计数器的行为与字典有很多相似的地方：它们将每个键映射至其出现的次数。 defaultdict? 第二十章：调试语法错误 确保你没有使用 Python 的关键字作为变量名称。 检查你在每个复合语句首行的末尾都加了冒号，包括for，while，if，和 def 语句。 确保代码中的字符串都有匹配地引号。确保所有的引号都是“直引号”，而不是“花引号”。 如果你有带三重引号的多行字符串，确保你正确地结束了字符串。一个没有结束的字符串会在程序的末尾产生 invalid token 错误，或者它会把剩下的程序看作字符串的一部分，直到遇到下一个字符串。 一个没有关闭的操作符(， { 以及 [使得 Python 把下一行继续看作当前语句的一部分。通常下一行会马上提示错误消息。 检查条件语句里面的 == 是不是写成了 = 。 确保每行的缩进是符合要求。Python 能够处理空格和制表符，但是如果混用则会出错。避免该问题的最好方法是使用一个了解 Python 语法、能够产生一致缩进的纯文本编辑器。 如果代码中包含有非ASCII字符串（包括字符串和注释），可能会出错，尽管 Python 3 一般能处理非ASCII字符串。从网页或其他源粘贴文本时，要特别注意。 第二十一章：算法分析算法分析的实际目的是预测不同算法的性能，用于指导设计决策。 增长量级假设你已经分析了两个算法，并能用输入计算量的规模表示它们的运行时间： 若算法 A 用 100n+1 步解决一个规模为 n 的问题；而算法 B 用 n^2+n+1 步。 下表列出了这些算法对于不同问题规模的运行时间： Input Run time of Run time of size Algorithm A Algorithm B 10 1001 111 100 10 001 10 101 1 000 100 001 1 001 001 10 000 1 000 001 &gt;10^10 增长量级(order of growth)是一个函数集合，集合中函数的增长行为被认为是相当的。 例如2n、100n和n+1属于相同的增长量级，可用 大O符号(Big-Oh notation) 写成O(n)， 而且常被称作 线性级 (linear)，因为集合中的每个函数随着n线性增长。 下表列出了算法分析中最通常的一些增长量级，按照运行效率从高到低排列 。 Order of Growth Name 名称 O(1) constant 常数级 O(logbn) logarithmic 对数级 O(n) linear 线性级 O(nlogbn) linearithmic 线性对数级 O(n2) quadratic 二次方级 O(n3) cubic 三次方级 O(cn) exponential 指数级 Python基本运算操作分析在 Python 中，大部分算术运算的开销是常数级的；索引操作 — 在序列或字典中读写元素 — 的增长量级也是常数级的，和数据结构的大小无关。 搜索算法分析搜索 (search)算法，接受一个集合以及一个目标项，并判断该目标项是否在集合中，通常返回目标的索引值。最坏的情况下， 它不得不遍历全部集合，所以运行时间是线性的。序列的 in 操作符使用线性搜索；字符串方法 find 和 count 也使用线性搜索。如果元素在序列中是排序好的，你可以用 二分搜素 (bisection search) ，它的增长量级是 O(logn) 。 二分搜索比线性搜索快很多，但是它要求已排序的序列，因此使用时需要做额外的工作。 哈希表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Packages-R包汇总（更新中）]]></title>
      <url>%2F2017%2F04%2F06%2FPackages-R%E5%8C%85%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[加载/当前R包的清单12&gt; getOption(&quot;defaultPackages&quot;)&gt; (packages) 实现ggplot2的图形界面操作 RcmdrPlugin.KMggplot2包是Rcmdr包的一个插件。它通过集成ggplot2包可以实现Kamplan-Meier图，直方图，Q-Q 图，箱线图，误差条图，散点图，线图，饼图，条形图，等高线图，分布图等的“鼠标化”操作。 交互数据可视化rCharts包：该包直接在R中生成基于D3的Web界面。123&gt; install.packages(&quot;devtools&quot;)&gt; require(devtools)&gt; install_github(&apos;rCharts&apos;, &apos;ramnathv&apos;) 量化分析quantmod包12&gt; install.packages(&quot;quantmod&quot;)&gt; require(quantmod) 绘制中国地图12&gt; install.packages(&quot;maps&quot;)&gt; library(&quot;maps&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ggplot2的图形语法（待续）]]></title>
      <url>%2F2017%2F04%2F06%2Fggplot2%E7%9A%84%E5%9B%BE%E5%BD%A2%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[安装包ggplot2的核心理念是将绘图与数据分离，数据相关的绘图与数据无关的绘图分离。按图层作图，图层(layer)之间是通过“+”来粘合构图的。想使用ggplot之前，需要先安装相应的包：（镜像选择china:beijing） 12install.packages(&quot;ggplot2&quot;) # 在R中安装ggplot2包library(ggplot2) # 载入ggplot2包 图形部件数据(data) 在ggplot2中, 所接受的数据集必须为数据框data.frame格式，这种格式带来的好处是数据易于存储, 也能在保留原有的绘图参数下, 用%+%方便地变更已有数据集。用mtcars.c替换mtcars12mtcars.c &lt;- transform(mtcars, mpg = mpg^2)p %+% mtcars.c 而ggplot2进行数据分组时必须根据行, 而不能根据列，变量不在是放在各个列上, 而是拍成一列, 每一个变量都分别占其中的几行, 这样就能方便的对每个变量进行分组。reshape2中的函数可以融合(melt)和重铸(cast)数据框中的数据。 12install.packages(&quot;reshape2&quot;) #在R中安装reshape2包library(reshape2) #载入reshape2包 映射(mapping) 映射是将一个变量中离散或连续的数据与一个图形属性中以不同的参数来相互关联, 而设定能够将这个变量中所有的数据统一为一个图形属性。 aes()函数是ggplot2中的映射函数 12p&lt;- ggplot(data= mtcars, mapping= aes(x= wt, y= hp))p+ geom_point(color= “blue”) #设定散点的颜色为蓝色 分组(group)也是ggplot2种映射关系的一种 1p &lt;-ggplot(data=mtcars, mapping=aes(x=wt, y=hp, group=factor(gear)))+geom_line() 图层(layer) ggplot2中的图层：每个图层可以代表一个图形组件, 例如下面要介绍的几何对象、统计变换等图形组件, 这些组件以图层的方式叠加在一起构成一个绘图的整体，在每个图层中的图形组件又可以分别设定数据、映射或其他相关参数, 因此组件之间又是具有相对独立性的。 几何对象(geom)统计变换(stat)统计变换即对数据进行统计变化, 通常以某种方式对数据信息进行汇总, 例如通过stat_smooth()添加光滑曲线。 标度(scale)标度控制着数据到图形属性的映射, 更重要的一点是标度将我们的数据转化为视觉上可以感知的东西, 如大小、颜色、位置和形状。所以通过标度可以修改坐标轴和图例的参数。 坐标系(coord)分面(facet)主题(theme)主题系统控制着图形中的非数据元素外观, 它不会影响几何对象和标度等数据元素。主题修改是一个对绘图精雕细琢的过程, 主要对标题、坐标轴标签、图例标签等文字调整, 以及网格线、背景、轴须的颜色搭配。 存储和输出(ggsave)ggplot2支持eps矢量图输出, 其他可以支持的格式包括png, jpg, pdf等, 并通过ggsave可以方便的进行修改。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[时间序列的分位数回归（待续）]]></title>
      <url>%2F2017%2F04%2F06%2F%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%88%86%E4%BD%8D%E6%95%B0%E5%9B%9E%E5%BD%92%2F</url>
      <content type="text"><![CDATA[复合分位数回归 估计回归系数的传统方法是最小二乘法，最小二乘法对于误差项的要求是非常严苛的，在实际问题中，数据往往会出现 尖峰厚尾 等特征，或者是存在明显的异方差情况，这时候若使用LS方法对回归系数进行估计，其稳健性是很差的。分位数回归有效的解决了上述问题，符合分位数回归是分位数回归的一种更一般性的推广。【尖峰厚尾】 金融数据的尖峰厚尾特征是相比较标准正态分布来说的，标准正态分布的偏度为0，峰度为3，通常做实证分析时，会假设金融数据为正态分布，这样方便建模分析，但是实证表明，很多数据并不符合正态分布，而更像尖峰厚尾，就是峰度比3大，两边的尾巴比正态分布厚，没有下降得这么快。厚尾分布主要是出现在金融数据中，例如证券的收益率。 从图形上说，较正态分布图的尾部要厚，峰处要尖。直观些说，就是这些数据出现极端值的概率要比正态分布数据出现极端值的概率大。因此，不能简单的用正态分布去拟合这些数据的分布，从而做一些统计推断。一般来说，通过实证分析发现，自由度为5或6的t分布拟合的较好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据科学1.2 数据结构（待续）]]></title>
      <url>%2F2017%2F03%2F30%2F%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A61.2%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[绪论数据结构基本概念数据项：一个数据元素由若干数据项组成数据元素：组成数据对象的基本单位数据对象：性质相同的数据元素的集合（类似于数组一般） 数据结构：计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。数据结构例子 集合结构：数据元素之间除了同属于一个集合的关系 线性结构：数据元素之间存在着一对一的线性关系 树状结构：数据元素之间存在着一对多的层次关系 图状结构或网状结构：元素之间存在着多对多的任意关系]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo系列]]></title>
      <url>%2F2017%2F03%2F29%2FHexo%E7%B3%BB%E5%88%97%2F</url>
      <content type="text"><![CDATA[本文旨在帮助刚接触 Github 新手，想利用 Github 来创建自己的站点、个人博客等。使用 Hexo + Next 搭建静态博客 Hexo 安装完之后，主题的初始化格式非常简单。next主题的作者提供了一个非常好的方式，就是 custom 文件，这个文件就是用来让用户在里面添加自己的样式去覆盖主题原有的样式。推荐以下3篇个性化设置文章。 Hexo搭建博客的个性化设置一Hexo搭建博客的个性化设置二Hexo搭建博客的个性化设置三Hexo 3.1.1 静态博客搭建指南]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python爬虫：Scrapy框架安装配置]]></title>
      <url>%2F2017%2F03%2F10%2Fpython%2FPython-%E7%88%AC%E8%99%AB%E4%B9%8BScrapy%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[本篇文章中Python的安装是基于window平台，安装Scrapy之前确保已经安装好下列程序: 安装Python 安装过程见→ python初级教程：入门详解 在命令行中输入 python –version，如果没有提示错误，则安装成功。 安装pywin32 在windows下，必须安装pywin32，安装地址： http://sourceforge.net/projects/pywin32/ http://www.softpedia.com/get/Programming/Other-Programming-Files/PyWin32.shtml#download 下载直接双击安装，安装完毕之后在python命令行下输入import win32com,如果没有提示错误，则证明安装成功! 安装pip pip是用来安装其他必要包的工具，首先下载get-pip.py 下载好之后，选中该文件夹所在路径，执行命令python get-pip.py 执行命令后便会安装好pip，同时，它帮你安装了setuptools 安装完了之后在命令行执行pip --version 安装完后若提醒版本低，可进行更新python -m pip install --update pip pip is already installed if you’re using Python 2 &gt;=2.7.9 or Python 3 &gt;=3.4 安装pyOPENSSL 在Windows下，是没有预装pyOPENSSL的，而在Linux下是已经安装好的。 安装地址：https://launchpad.net/pyopenssl (下载pyOpenSSL-0.11.winxp32-py2.7) 如果出现了Python Version 2.7 required which was not found in the registry错误！ 解决方法：新建一个register.py 文件，把以下代码贴进去，保存 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# script to register Python 2.0 or later for use with win32all# and other extensions that require Python registry settings## written by Joakim Loew for Secret Labs AB / PythonWare## source:# http://www.pythonware.com/products/works/articles/regpy20.htm# import sys from _winreg import * # tweak as necessaryversion = sys.version[:3]installpath = sys.prefix regpath = "SOFTWARE\\Python\\Pythoncore\\%s\\" % (version)installkey = "InstallPath"pythonkey = "PythonPath"pythonpath = "%s;%s\\Lib\\;%s\\DLLs\\" % ( installpath, installpath, installpath) def RegisterPy(): try: reg = OpenKey(HKEY_CURRENT_USER, regpath) except EnvironmentError as e: try: reg = CreateKey(HKEY_CURRENT_USER, regpath) SetValue(reg, installkey, REG_SZ, installpath) SetValue(reg, pythonkey, REG_SZ, pythonpath) CloseKey(reg) except: print "*** Unable to register!" return print "--- Python", version, "is now registered!" return if (QueryValue(reg, installkey) == installpath and QueryValue(reg, pythonkey) == pythonpath): CloseKey(reg) print "=== Python", version, "is already registered!" return CloseKey(reg) print "*** Unable to register!" print "*** You probably have another Python installation!" if __name__ == "__main__": RegisterPy() 在cmd 中运行python脚本 双击安装 pyOpenSSL-0.11.winxp32-py2.7 安装 lxml第一种办法： lxml的详细介绍 link ，是一种使用 Python 编写的库，可以迅速、灵活地处理 XML 直接执行如下命令pip install lxml就可完成安装 如果提示 Microsoft Visual C++库没安装，则 link 下载支持的库。 可能报错： 第二种办法：步骤1：安装wheel，cmd命令行运行：pip install wheel步骤2：在这里http://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml下载对应的.whl文件Ctrl + F，输入lxml，找到下面这段，cp后面是Python的版本号，27表示2.7。 lxml‑3.6.4‑cp27‑cp27m‑win32.whllxml‑3.6.4‑cp27‑cp27m‑win_amd64.whllxml‑3.6.4‑cp34‑cp34m‑win32.whllxml‑3.6.4‑cp34‑cp34m‑win_amd64.whllxml‑3.6.4‑cp35‑cp35m‑win32.whllxml‑3.6.4‑cp35‑cp35m‑win_amd64.whllxml‑3.6.4‑cp36‑cp36m‑win32.whllxml‑3.6.4‑cp36‑cp36m‑win_amd64.whl 步骤3：进入.whl所在的文件夹，执行命令pip install 带后缀的完整文件名即可完成安装pip安装报错：is not a supported wheel on this platform解决方法：在shell中输入import pip; print(pip.pep425tags.get_supported())可以获取到pip支持的文件名还有版本12345678import pip; print(pip.pep425tags.get_supported())[('cp27', 'none', 'win_amd64'), ('cp27', 'none', 'any'), ('cp2', 'none', 'any'), ('cp26', 'none', 'any'), ('cp25', 'none', 'any'), ('cp24', 'none', 'any'), ('cp23', 'none', 'any'), ('cp22', 'none', 'any'), ('cp21', 'none', 'any'), ('cp20', 'none', 'any'), ('py27', 'none', 'any'), ('py2', 'none', 'any'), ('py26', 'none', 'any'), ('py25', 'none', 'any'), ('py24', 'none', 'any'), ('py23', 'none', 'any'), ('py22', 'none', 'any'), ('py21', 'none', 'any'), ('py20', 'none', 'any')] 可以发现上面下载的文件名格式是不支持的，修改为：lxml-3.7.3-cp27-none-win_amd64.whl即可成功安装。 安装Scrapy 最后就是激动人心的时刻啦，上面的铺垫做好了，我们终于可以享受到胜利的果实啦！ 执行如下命令pip install Scrapy pip 会另外下载其他依赖的包，这些就不要我们手动安装啦，等待一会，大功告成！ 验证安装，输入 Scrapy 创建项目 scrapy startproject phone 发生问题： 问题原因：twist版本问题，twist版本高于需要的 输入pip freeze查看twist版本，用pip install twisted==13.1.0 替代更高的版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python安装]]></title>
      <url>%2F2017%2F03%2F09%2Fpython%2FPython-%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[文章转载 → Python初级教程 , 文章篇幅太长，下文做了精简。 本文是针对Python的初学者，从无到有的介绍Python语言如何入门，主要包括了：Python的简介，如何下载Python，如何安装Python，如何使用终端、Shell，IDE等各种开发环境进行Python开发，Python中的语法和基本知识、概念和逻辑，以及继续深入学习Python的方法，另外还整理一些值得参考的资料。 安装Python1. Python官网不是太稳定，对于国内开发者来说，时不时会出现无法访问的情况。可以选择国内的镜像进行下载。 官网上的下载地址 国内的镜像 http://www.python.org/ftp/python/http://python.org/getit/releases/ http://mirrors.sohu.com/python/ 2. Python有2.x版本和3.x版本的区别。对于初学者，推荐先用Python 2.x版本的。 总结Python2(Python 2.x版本）和Python3（Python 3.x版本）之间的区别 如何在Windows系统中安装Python 开发环境 针对初学者，建议使用windows的cmd下，去运行python脚本。目的很明确：很多东西的学习，其本质上，都是需要一个循序渐进的过程的，学习Python语言同样如此。在没有学会走路，即如何搞懂Windows的cmd下运行Python脚本，就想学会跑了，即直接利用Python的IDE，包括shell和第三方开发环境，结果就是，很多东西，还是不明白到底是为什么，理解的不透彻。而当Python的基本知识，基本开发流程熟悉了之后，再建议你去使用第三方的Python的IDE。 先：Windows的cmd + Notepad++ 再：选用某个IDE，比如PyScripter，Ulipad，Eclipse+PyDev等。 Anaconda是一个用于科学计算的Python发行版。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。Anaconda的安装 Conda环境管理conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。123456789101112131415161718# 创建一个名为python34的环境，指定Python版本是3.4（不用管是3.4.x，conda会为我们自动寻找3.4.x中的最新版本）conda create --name python34 python=3.4# 安装好后，使用activate激活某个环境activate python34 # for Windowssource activate python34 # for Linux &amp; Mac# 激活后，会发现terminal输入的地方多了python34的字样，实际上，此时系统做的事情就是把默认2.7环境从PATH中去除，再把3.4对应的命令加入PATH# 此时，再次输入python --version# 可以得到`Python 3.4.5 :: Anaconda 4.1.1 (64-bit)`，即系统已经切换到了3.4的环境# 如果想返回默认的python 2.7环境，运行deactivate python34 # for Windowssource deactivate python34 # for Linux &amp; Mac# 删除一个已有的环境conda remove --name python34 --all Conda的包管理Conda的包管理就比较好理解了，这部分功能与pip类似。例如，如果需要安装scipy：1234567# 安装scipyconda install scipy# conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库） # 查看已经安装的packagesconda list# 最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包 conda的一些常用操作如下：12345678910111213141516171819# 查看当前环境下已安装的包conda list # 查看某个指定环境的已安装包conda list -n python34 # 查找package信息conda search numpy # 安装packageconda install -n python34 numpy# 如果不用-n指定环境名称，则被安装在当前活跃环境# 也可以通过-c指定通过某个channel安装 # 更新packageconda update -n python34 numpy # 删除packageconda remove -n python34 numpy 前面已经提到，conda将conda、python等都视为package，因此，完全可以使用conda来管理conda和python的版本，例如123456789# 更新conda，保持conda最新conda update conda # 更新anacondaconda update anaconda # 更新pythonconda update python# 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本 设置国内镜像如果需要安装很多packages，你会发现conda下载的速度经常很慢，因为Anaconda.org的服务器在国外。所幸的是，清华TUNA镜像源有Anaconda仓库的镜像，我们将其加入conda的配置即可：123456# 添加Anaconda的TUNA镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉 # 设置搜索时显示通道地址conda config --set show_channel_urls yes 使用问题在window的cmd中运行python结果却调用了文本编辑器去打开了，而不是去调用Python解析器去运行python文件 解决办法：修改后缀为.py文件的打开方式，设置为python]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[分类和预测]]></title>
      <url>%2F2017%2F03%2F03%2F%E5%88%86%E7%B1%BB%E5%92%8C%E9%A2%84%E6%B5%8B%2F</url>
      <content type="text"><![CDATA[分类：预测类对象的分类标号，根据训练数据集和类标号属性，构建模型来分类现有数据，并用来分类新数据。银行需要弄清楚那些贷款申请者是安全的，哪些是有风险的。预测：建立连续函数值模型，比如预测空缺值，或者预测顾客在某项活动中的花费。银行需要预测贷给某个顾客多少钱是安全的，预测一个连续值函数或有序值，常用方法是回归分析。 典型应用：欺诈检测 市场定位 医疗诊断 准备分类和预测的数据数据预处理数据清理通过填写空缺值，平滑噪声数据，识别删除孤立点，并解决不一致来清理数据。 空缺值 噪声数据(数据平滑技术) 1. 分箱 2. 聚类 3. 回归 - 忽略元组- 人工填写空缺值- 使用固定值- 使用属性平均值- 使用最有可能值 - 箱的深度：表示不同的箱里有相同个数的数据- 箱的宽度：每个箱值的取值区间是个常数- 平滑的办法：① 按箱平均值平滑② 按箱中值平滑③ 按箱边界值平滑 - 每个簇中的数据用其中心值代替- 忽略孤立点- 先通过聚类等办法找出孤立点。- 人工再审查这些孤立点 - 通过构造函数来符合数据变化的趋势，这样可以用一个变量预测另一个变量。① 线性回归② 多线性回归 数据清洗 格式标准化 异常数据清除 错误纠正 重复数据清除 数据变换 平滑 聚集 数据概化 规范化 属性构造 数据立方体聚集 最小 最大规范化 有给定的属性构造和添加新的属性，以帮助提高精度和对高纬度数据结构的理解 数据归约 数据聚集 维归约 数据压缩 数值归约 - 删除不相关属性属性子集选择 - 小波变换- 主要成分分析 - 回归和对数线性模型线性回归对数线性模型- 直方图等宽等深V-最优maxDiff 相关分析 在分类和回归之前进行，它试图识别与分类和回归过程显著相关的属性。 属性子集选择通过删除不相关或冗余的属性减少数据量。属性子集选择的目标是找出最小属性集，使得数据类的概率分布尽可能地接近使用所有属性得到的原分布。 向前选择 向后删除 决策树归纳 初始属性集：{A1，A2，A3，A4，A5，A6}初始化归约集：{ }=&gt; {A1}=&gt; {A1，A4}=&gt; 归约后的属性集：{A1，A4，A6} 初始属性集：{A1，A2，A3，A4，A5，A6}=&gt; {A1，A3，A4，A5，A6} =&gt; {A1，A4，A5，A6}=&gt; 归约后的属性集：{A1，A4，A6} 初始属性集：{A1，A2，A3，A4，A5，A6}当决策树归纳用于属性子集选择时，由给定的数据构造决策树。不出现在树中的所有属性假定是不相关的。出现在树中的属性形成归约后的属性子集。 这些方法的结束条件可以不同。该过程可以使用一个度量阈值来决定何时停止属性选择过程。 分类办法决策树 决策树构建，使用属性选择度量来选择将元组最好的划分为不同的类的属性，递归的通过选定的属性，来划分样本（必须是离散值） 树剪枝，决策树建立时，许多分枝反映的是训练数据中的噪声和离群点，树剪枝试图识别并减去这种分枝，以提高对未知数据分类的准确性 提取分类规则，从根到树叶的每条路径创建一个规则，并以“IF-THEN”形式的分类规则表示。示例： IF age=”youth” AND student=”no” THEN buys_computer=”no” 属性选择度量是一种选择分裂准则，将给定类标号的训练元组最好的进行划分的方法，常用的有：① 信息增益；② 增益率；③ Gini 指标。 贝叶斯分类思想：根据某些个先验概率计算Y变量属于某个类别的后验概率比较分类办法使用下列标准比较分类和预测方法 分类器的准确率度量（Accuracy）：模型正确预测新数据的类编号的能力 分类器的灵敏性（Sensitivity）度量和特效性（Specificity）度量 假设已经训练的分类器将医疗数据元组分类为“cancer”和“not_cancer”。90%的准确率使该分类器看上去相当准确，但是，如果只有 3%~4%的训练元组是“cancer”，显然90%的准确率是不可以接受的（比如该分类器只能对“not_cancer”类的元组正确分类，对 “cancer”类的元组全部分类错误）。我们希望有某种度量能够对分类器识别“cancer”元组（设为正元组）和“not_cancer”元组（设为负元组）进行分别评估，为此引入灵敏性（Sensitivity）度量和特效性（Specificity）度量。 速度：产生和使用模型的计算花销 健壮性：给定噪声数据或有空缺值的数据，模型正确预测的能力 可伸缩性：对大量数据，有效的构建分类器或预测器的能力 可解释性：学习模型提供的理解和洞察的层次 过度拟合（Overfit）问题 Overfit是这样一种现象：一个假设在训练数据上能够获得比其他假设更好的拟合，但是在训练数据外的数据集上却不能很好的拟合数据。此时我们就 叫这个假设出现了overfit的现象。 过度拟合产生的原因 噪声数据导致过度拟合由于数据中的噪声和孤立点，许多分枝反应的是训练数据中的异常。 缺乏代表性样本导致过度拟合在训练数据缺乏具有代表的样本的情况下，往往需要继续细化模型才能得到较好拟合训练集的模型，这样得到的模型同样可能具有较高的泛化误差。我们将训练好的模型检验训练集数据，得到的误差率称之为训练误差。将该模型用于检验测试样本，得到的误差率称之为泛化误差。 避免过度拟合的策略与上述两个导致模型过度拟合的因素同时出现的是模型的复杂度。模型越复杂出现过度拟合的概率就越高。因此，对于给定具有相同泛化误差的模型，我们往往更倾向于较为简单的模型，这就是所谓的Occam剃刀（Occam’s Razor）原则。为了避免过度拟合，降低决策树的复杂度，通常的策略是剪枝，该策略采用统计方法删除最不可靠的分支，以提高对未来分类识别的速度和分类 识别新数据的能力。 先剪枝（pre-pruning）法先剪枝法是通过提前停止分支的生长过程，即通过在当前结点上就判断是否需要继续划分该结点所包含训练样本集来实现的。这就需要更为限制性的约束条件，如当观察到衡量不纯性的度量低于某个阈值就停止分支的生长。该方法的优点在于避免产生过分拟合训练数据的过于复杂的子树。但是我们很难为提前终止选择正确的阈值，阈值太高将导致拟合不足，阈值太低则不能充分解决过度拟合问题。 后剪枝（post-pruning）法后剪枝法从一个“充分生长”的树中，按照自底向上的方式修剪多余的分支。对于树中的每个非树叶节点，计算该节点上的子树被剪枝可能出现的期望错误率。使用一个独立的测试集来评估每棵树的准确率，就能得到具有最小期望错误率的决策树。① 用新的叶子节点替换子树，该叶子节点的类标签由子树记录中的多数类确定；② 用子树中最常用的分支代替子树。 J48决策树算法采用了子树提升（Subtree Raising）与子树替换（Subtree Replacement）的修剪策略。计算修剪前后的预期分类错误率，如果修剪导致预期分类错误率变大，则放弃剪枝，保留该结点的相应分支，否则就将相应节点分支修剪删除。在产生一系列经过修剪的决策树候选之后，利用一个独立的测试数据集对这些经过修剪的决策树的分类的准确性进行评价，保留下那些预期分类错误率最小的决策树。与先剪枝相比，后剪枝倾向于产生更好的结果 检验和解释结果在实际问题中，数据往往有许多噪音，所以必须对统计结果进行显著性检验、准确性检验的基础上，对结果进行经验性的解释，已确定结果hi合乎逻辑、合乎情理、合乎直觉的，是能够解决实际问题的，而不是噪音、数据偏差（bias）或过拟合（overfit）的结果。]]></content>
    </entry>

    
  
  
</search>
